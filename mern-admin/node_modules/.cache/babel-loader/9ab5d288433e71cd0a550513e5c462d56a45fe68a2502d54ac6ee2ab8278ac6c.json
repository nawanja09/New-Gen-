{"ast":null,"code":"let {\n  list\n} = require('postcss');\nlet parser = require('postcss-value-parser');\nlet Browsers = require('./browsers');\nlet vendor = require('./vendor');\nclass Transition {\n  constructor(prefixes) {\n    this.props = ['transition', 'transition-property'];\n    this.prefixes = prefixes;\n  }\n\n  /**\r\n   * Process transition and add prefixes for all necessary properties\r\n   */\n  add(decl, result) {\n    let prefix, prop;\n    let add = this.prefixes.add[decl.prop];\n    let vendorPrefixes = this.ruleVendorPrefixes(decl);\n    let declPrefixes = vendorPrefixes || add && add.prefixes || [];\n    let params = this.parse(decl.value);\n    let names = params.map(i => this.findProp(i));\n    let added = [];\n    if (names.some(i => i[0] === '-')) {\n      return;\n    }\n    for (let param of params) {\n      prop = this.findProp(param);\n      if (prop[0] === '-') continue;\n      let prefixer = this.prefixes.add[prop];\n      if (!prefixer || !prefixer.prefixes) continue;\n      for (prefix of prefixer.prefixes) {\n        if (vendorPrefixes && !vendorPrefixes.some(p => prefix.includes(p))) {\n          continue;\n        }\n        let prefixed = this.prefixes.prefixed(prop, prefix);\n        if (prefixed !== '-ms-transform' && !names.includes(prefixed)) {\n          if (!this.disabled(prop, prefix)) {\n            added.push(this.clone(prop, prefixed, param));\n          }\n        }\n      }\n    }\n    params = params.concat(added);\n    let value = this.stringify(params);\n    let webkitClean = this.stringify(this.cleanFromUnprefixed(params, '-webkit-'));\n    if (declPrefixes.includes('-webkit-')) {\n      this.cloneBefore(decl, `-webkit-${decl.prop}`, webkitClean);\n    }\n    this.cloneBefore(decl, decl.prop, webkitClean);\n    if (declPrefixes.includes('-o-')) {\n      let operaClean = this.stringify(this.cleanFromUnprefixed(params, '-o-'));\n      this.cloneBefore(decl, `-o-${decl.prop}`, operaClean);\n    }\n    for (prefix of declPrefixes) {\n      if (prefix !== '-webkit-' && prefix !== '-o-') {\n        let prefixValue = this.stringify(this.cleanOtherPrefixes(params, prefix));\n        this.cloneBefore(decl, prefix + decl.prop, prefixValue);\n      }\n    }\n    if (value !== decl.value && !this.already(decl, decl.prop, value)) {\n      this.checkForWarning(result, decl);\n      decl.cloneBefore();\n      decl.value = value;\n    }\n  }\n\n  /**\r\n   * Does we already have this declaration\r\n   */\n  already(decl, prop, value) {\n    return decl.parent.some(i => i.prop === prop && i.value === value);\n  }\n\n  /**\r\n   * Show transition-property warning\r\n   */\n  checkForWarning(result, decl) {\n    if (decl.prop !== 'transition-property') {\n      return;\n    }\n    let isPrefixed = false;\n    let hasAssociatedProp = false;\n    decl.parent.each(i => {\n      if (i.type !== 'decl') {\n        return undefined;\n      }\n      if (i.prop.indexOf('transition-') !== 0) {\n        return undefined;\n      }\n      let values = list.comma(i.value);\n      // check if current Rule's transition-property comma separated value list needs prefixes\n      if (i.prop === 'transition-property') {\n        values.forEach(value => {\n          let lookup = this.prefixes.add[value];\n          if (lookup && lookup.prefixes && lookup.prefixes.length > 0) {\n            isPrefixed = true;\n          }\n        });\n        return undefined;\n      }\n      // check if another transition-* prop in current Rule has comma separated value list\n      hasAssociatedProp = hasAssociatedProp || values.length > 1;\n      return false;\n    });\n    if (isPrefixed && hasAssociatedProp) {\n      decl.warn(result, 'Replace transition-property to transition, ' + 'because Autoprefixer could not support ' + 'any cases of transition-property ' + 'and other transition-*');\n    }\n  }\n\n  /**\r\n   * Remove all non-webkit prefixes and unprefixed params if we have prefixed\r\n   */\n  cleanFromUnprefixed(params, prefix) {\n    let remove = params.map(i => this.findProp(i)).filter(i => i.slice(0, prefix.length) === prefix).map(i => this.prefixes.unprefixed(i));\n    let result = [];\n    for (let param of params) {\n      let prop = this.findProp(param);\n      let p = vendor.prefix(prop);\n      if (!remove.includes(prop) && (p === prefix || p === '')) {\n        result.push(param);\n      }\n    }\n    return result;\n  }\n  cleanOtherPrefixes(params, prefix) {\n    return params.filter(param => {\n      let current = vendor.prefix(this.findProp(param));\n      return current === '' || current === prefix;\n    });\n  }\n\n  /**\r\n   * Return new param array with different name\r\n   */\n  clone(origin, name, param) {\n    let result = [];\n    let changed = false;\n    for (let i of param) {\n      if (!changed && i.type === 'word' && i.value === origin) {\n        result.push({\n          type: 'word',\n          value: name\n        });\n        changed = true;\n      } else {\n        result.push(i);\n      }\n    }\n    return result;\n  }\n\n  /**\r\n   * Add declaration if it is not exist\r\n   */\n  cloneBefore(decl, prop, value) {\n    if (!this.already(decl, prop, value)) {\n      decl.cloneBefore({\n        prop,\n        value\n      });\n    }\n  }\n\n  /**\r\n   * Check property for disabled by option\r\n   */\n  disabled(prop, prefix) {\n    let other = ['order', 'justify-content', 'align-self', 'align-content'];\n    if (prop.includes('flex') || other.includes(prop)) {\n      if (this.prefixes.options.flexbox === false) {\n        return true;\n      }\n      if (this.prefixes.options.flexbox === 'no-2009') {\n        return prefix.includes('2009');\n      }\n    }\n    return undefined;\n  }\n\n  /**\r\n   * Find or create separator\r\n   */\n  div(params) {\n    for (let param of params) {\n      for (let node of param) {\n        if (node.type === 'div' && node.value === ',') {\n          return node;\n        }\n      }\n    }\n    return {\n      after: ' ',\n      type: 'div',\n      value: ','\n    };\n  }\n\n  /**\r\n   * Find property name\r\n   */\n  findProp(param) {\n    let prop = param[0].value;\n    if (/^\\d/.test(prop)) {\n      for (let [i, token] of param.entries()) {\n        if (i !== 0 && token.type === 'word') {\n          return token.value;\n        }\n      }\n    }\n    return prop;\n  }\n\n  /**\r\n   * Parse properties list to array\r\n   */\n  parse(value) {\n    let ast = parser(value);\n    let result = [];\n    let param = [];\n    for (let node of ast.nodes) {\n      param.push(node);\n      if (node.type === 'div' && node.value === ',') {\n        result.push(param);\n        param = [];\n      }\n    }\n    result.push(param);\n    return result.filter(i => i.length > 0);\n  }\n\n  /**\r\n   * Process transition and remove all unnecessary properties\r\n   */\n  remove(decl) {\n    let params = this.parse(decl.value);\n    params = params.filter(i => {\n      let prop = this.prefixes.remove[this.findProp(i)];\n      return !prop || !prop.remove;\n    });\n    let value = this.stringify(params);\n    if (decl.value === value) {\n      return;\n    }\n    if (params.length === 0) {\n      decl.remove();\n      return;\n    }\n    let double = decl.parent.some(i => {\n      return i.prop === decl.prop && i.value === value;\n    });\n    let smaller = decl.parent.some(i => {\n      return i !== decl && i.prop === decl.prop && i.value.length > value.length;\n    });\n    if (double || smaller) {\n      decl.remove();\n      return;\n    }\n    decl.value = value;\n  }\n\n  /**\r\n   * Check if transition prop is inside vendor specific rule\r\n   */\n  ruleVendorPrefixes(decl) {\n    let {\n      parent\n    } = decl;\n    if (parent.type !== 'rule') {\n      return false;\n    } else if (!parent.selector.includes(':-')) {\n      return false;\n    }\n    let selectors = Browsers.prefixes().filter(s => parent.selector.includes(':' + s));\n    return selectors.length > 0 ? selectors : false;\n  }\n\n  /**\r\n   * Return properties string from array\r\n   */\n  stringify(params) {\n    if (params.length === 0) {\n      return '';\n    }\n    let nodes = [];\n    for (let param of params) {\n      if (param[param.length - 1].type !== 'div') {\n        param.push(this.div(params));\n      }\n      nodes = nodes.concat(param);\n    }\n    if (nodes[0].type === 'div') {\n      nodes = nodes.slice(1);\n    }\n    if (nodes[nodes.length - 1].type === 'div') {\n      nodes = nodes.slice(0, +-2 + 1 || undefined);\n    }\n    return parser.stringify({\n      nodes\n    });\n  }\n}\nmodule.exports = Transition;","map":{"version":3,"names":["list","require","parser","Browsers","vendor","Transition","constructor","prefixes","props","add","decl","result","prefix","prop","vendorPrefixes","ruleVendorPrefixes","declPrefixes","params","parse","value","names","map","i","findProp","added","some","param","prefixer","p","includes","prefixed","disabled","push","clone","concat","stringify","webkitClean","cleanFromUnprefixed","cloneBefore","operaClean","prefixValue","cleanOtherPrefixes","already","checkForWarning","parent","isPrefixed","hasAssociatedProp","each","type","undefined","indexOf","values","comma","forEach","lookup","length","warn","remove","filter","slice","unprefixed","current","origin","name","changed","other","options","flexbox","div","node","after","test","token","entries","ast","nodes","double","smaller","selector","selectors","s","module","exports"],"sources":["D:/SLIIT IT/Year 2 semster 2/ITP/Project/Smart TechHub Management System/New-Gen-/mern-admin/node_modules/autoprefixer/lib/transition.js"],"sourcesContent":["let { list } = require('postcss')\r\nlet parser = require('postcss-value-parser')\r\n\r\nlet Browsers = require('./browsers')\r\nlet vendor = require('./vendor')\r\n\r\nclass Transition {\r\n  constructor(prefixes) {\r\n    this.props = ['transition', 'transition-property']\r\n    this.prefixes = prefixes\r\n  }\r\n\r\n  /**\r\n   * Process transition and add prefixes for all necessary properties\r\n   */\r\n  add(decl, result) {\r\n    let prefix, prop\r\n    let add = this.prefixes.add[decl.prop]\r\n    let vendorPrefixes = this.ruleVendorPrefixes(decl)\r\n    let declPrefixes = vendorPrefixes || (add && add.prefixes) || []\r\n\r\n    let params = this.parse(decl.value)\r\n    let names = params.map(i => this.findProp(i))\r\n    let added = []\r\n\r\n    if (names.some(i => i[0] === '-')) {\r\n      return\r\n    }\r\n\r\n    for (let param of params) {\r\n      prop = this.findProp(param)\r\n      if (prop[0] === '-') continue\r\n\r\n      let prefixer = this.prefixes.add[prop]\r\n      if (!prefixer || !prefixer.prefixes) continue\r\n\r\n      for (prefix of prefixer.prefixes) {\r\n        if (vendorPrefixes && !vendorPrefixes.some(p => prefix.includes(p))) {\r\n          continue\r\n        }\r\n\r\n        let prefixed = this.prefixes.prefixed(prop, prefix)\r\n        if (prefixed !== '-ms-transform' && !names.includes(prefixed)) {\r\n          if (!this.disabled(prop, prefix)) {\r\n            added.push(this.clone(prop, prefixed, param))\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    params = params.concat(added)\r\n    let value = this.stringify(params)\r\n\r\n    let webkitClean = this.stringify(\r\n      this.cleanFromUnprefixed(params, '-webkit-')\r\n    )\r\n    if (declPrefixes.includes('-webkit-')) {\r\n      this.cloneBefore(decl, `-webkit-${decl.prop}`, webkitClean)\r\n    }\r\n    this.cloneBefore(decl, decl.prop, webkitClean)\r\n    if (declPrefixes.includes('-o-')) {\r\n      let operaClean = this.stringify(this.cleanFromUnprefixed(params, '-o-'))\r\n      this.cloneBefore(decl, `-o-${decl.prop}`, operaClean)\r\n    }\r\n\r\n    for (prefix of declPrefixes) {\r\n      if (prefix !== '-webkit-' && prefix !== '-o-') {\r\n        let prefixValue = this.stringify(\r\n          this.cleanOtherPrefixes(params, prefix)\r\n        )\r\n        this.cloneBefore(decl, prefix + decl.prop, prefixValue)\r\n      }\r\n    }\r\n\r\n    if (value !== decl.value && !this.already(decl, decl.prop, value)) {\r\n      this.checkForWarning(result, decl)\r\n      decl.cloneBefore()\r\n      decl.value = value\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Does we already have this declaration\r\n   */\r\n  already(decl, prop, value) {\r\n    return decl.parent.some(i => i.prop === prop && i.value === value)\r\n  }\r\n\r\n  /**\r\n   * Show transition-property warning\r\n   */\r\n  checkForWarning(result, decl) {\r\n    if (decl.prop !== 'transition-property') {\r\n      return\r\n    }\r\n\r\n    let isPrefixed = false\r\n    let hasAssociatedProp = false\r\n\r\n    decl.parent.each(i => {\r\n      if (i.type !== 'decl') {\r\n        return undefined\r\n      }\r\n      if (i.prop.indexOf('transition-') !== 0) {\r\n        return undefined\r\n      }\r\n      let values = list.comma(i.value)\r\n      // check if current Rule's transition-property comma separated value list needs prefixes\r\n      if (i.prop === 'transition-property') {\r\n        values.forEach(value => {\r\n          let lookup = this.prefixes.add[value]\r\n          if (lookup && lookup.prefixes && lookup.prefixes.length > 0) {\r\n            isPrefixed = true\r\n          }\r\n        })\r\n        return undefined\r\n      }\r\n      // check if another transition-* prop in current Rule has comma separated value list\r\n      hasAssociatedProp = hasAssociatedProp || values.length > 1\r\n      return false\r\n    })\r\n\r\n    if (isPrefixed && hasAssociatedProp) {\r\n      decl.warn(\r\n        result,\r\n        'Replace transition-property to transition, ' +\r\n          'because Autoprefixer could not support ' +\r\n          'any cases of transition-property ' +\r\n          'and other transition-*'\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove all non-webkit prefixes and unprefixed params if we have prefixed\r\n   */\r\n  cleanFromUnprefixed(params, prefix) {\r\n    let remove = params\r\n      .map(i => this.findProp(i))\r\n      .filter(i => i.slice(0, prefix.length) === prefix)\r\n      .map(i => this.prefixes.unprefixed(i))\r\n\r\n    let result = []\r\n    for (let param of params) {\r\n      let prop = this.findProp(param)\r\n      let p = vendor.prefix(prop)\r\n      if (!remove.includes(prop) && (p === prefix || p === '')) {\r\n        result.push(param)\r\n      }\r\n    }\r\n    return result\r\n  }\r\n\r\n  cleanOtherPrefixes(params, prefix) {\r\n    return params.filter(param => {\r\n      let current = vendor.prefix(this.findProp(param))\r\n      return current === '' || current === prefix\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Return new param array with different name\r\n   */\r\n  clone(origin, name, param) {\r\n    let result = []\r\n    let changed = false\r\n    for (let i of param) {\r\n      if (!changed && i.type === 'word' && i.value === origin) {\r\n        result.push({ type: 'word', value: name })\r\n        changed = true\r\n      } else {\r\n        result.push(i)\r\n      }\r\n    }\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * Add declaration if it is not exist\r\n   */\r\n  cloneBefore(decl, prop, value) {\r\n    if (!this.already(decl, prop, value)) {\r\n      decl.cloneBefore({ prop, value })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check property for disabled by option\r\n   */\r\n  disabled(prop, prefix) {\r\n    let other = ['order', 'justify-content', 'align-self', 'align-content']\r\n    if (prop.includes('flex') || other.includes(prop)) {\r\n      if (this.prefixes.options.flexbox === false) {\r\n        return true\r\n      }\r\n\r\n      if (this.prefixes.options.flexbox === 'no-2009') {\r\n        return prefix.includes('2009')\r\n      }\r\n    }\r\n    return undefined\r\n  }\r\n\r\n  /**\r\n   * Find or create separator\r\n   */\r\n  div(params) {\r\n    for (let param of params) {\r\n      for (let node of param) {\r\n        if (node.type === 'div' && node.value === ',') {\r\n          return node\r\n        }\r\n      }\r\n    }\r\n    return { after: ' ', type: 'div', value: ',' }\r\n  }\r\n\r\n  /**\r\n   * Find property name\r\n   */\r\n  findProp(param) {\r\n    let prop = param[0].value\r\n    if (/^\\d/.test(prop)) {\r\n      for (let [i, token] of param.entries()) {\r\n        if (i !== 0 && token.type === 'word') {\r\n          return token.value\r\n        }\r\n      }\r\n    }\r\n    return prop\r\n  }\r\n\r\n  /**\r\n   * Parse properties list to array\r\n   */\r\n  parse(value) {\r\n    let ast = parser(value)\r\n    let result = []\r\n    let param = []\r\n    for (let node of ast.nodes) {\r\n      param.push(node)\r\n      if (node.type === 'div' && node.value === ',') {\r\n        result.push(param)\r\n        param = []\r\n      }\r\n    }\r\n    result.push(param)\r\n    return result.filter(i => i.length > 0)\r\n  }\r\n\r\n  /**\r\n   * Process transition and remove all unnecessary properties\r\n   */\r\n  remove(decl) {\r\n    let params = this.parse(decl.value)\r\n    params = params.filter(i => {\r\n      let prop = this.prefixes.remove[this.findProp(i)]\r\n      return !prop || !prop.remove\r\n    })\r\n    let value = this.stringify(params)\r\n\r\n    if (decl.value === value) {\r\n      return\r\n    }\r\n\r\n    if (params.length === 0) {\r\n      decl.remove()\r\n      return\r\n    }\r\n\r\n    let double = decl.parent.some(i => {\r\n      return i.prop === decl.prop && i.value === value\r\n    })\r\n    let smaller = decl.parent.some(i => {\r\n      return i !== decl && i.prop === decl.prop && i.value.length > value.length\r\n    })\r\n\r\n    if (double || smaller) {\r\n      decl.remove()\r\n      return\r\n    }\r\n\r\n    decl.value = value\r\n  }\r\n\r\n  /**\r\n   * Check if transition prop is inside vendor specific rule\r\n   */\r\n  ruleVendorPrefixes(decl) {\r\n    let { parent } = decl\r\n\r\n    if (parent.type !== 'rule') {\r\n      return false\r\n    } else if (!parent.selector.includes(':-')) {\r\n      return false\r\n    }\r\n\r\n    let selectors = Browsers.prefixes().filter(s =>\r\n      parent.selector.includes(':' + s)\r\n    )\r\n\r\n    return selectors.length > 0 ? selectors : false\r\n  }\r\n\r\n  /**\r\n   * Return properties string from array\r\n   */\r\n  stringify(params) {\r\n    if (params.length === 0) {\r\n      return ''\r\n    }\r\n    let nodes = []\r\n    for (let param of params) {\r\n      if (param[param.length - 1].type !== 'div') {\r\n        param.push(this.div(params))\r\n      }\r\n      nodes = nodes.concat(param)\r\n    }\r\n    if (nodes[0].type === 'div') {\r\n      nodes = nodes.slice(1)\r\n    }\r\n    if (nodes[nodes.length - 1].type === 'div') {\r\n      nodes = nodes.slice(0, +-2 + 1 || undefined)\r\n    }\r\n    return parser.stringify({ nodes })\r\n  }\r\n}\r\n\r\nmodule.exports = Transition\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}