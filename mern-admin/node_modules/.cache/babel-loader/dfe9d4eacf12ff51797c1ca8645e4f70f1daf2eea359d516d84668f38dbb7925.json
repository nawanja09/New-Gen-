{"ast":null,"code":"let parser = require('postcss-value-parser');\nlet range = require('normalize-range');\nlet OldValue = require('../old-value');\nlet Value = require('../value');\nlet utils = require('../utils');\nlet IS_DIRECTION = /top|left|right|bottom/gi;\nclass Gradient extends Value {\n  /**\r\n   * Do not add non-webkit prefixes for list-style and object\r\n   */\n  add(decl, prefix) {\n    let p = decl.prop;\n    if (p.includes('mask')) {\n      if (prefix === '-webkit-' || prefix === '-webkit- old') {\n        return super.add(decl, prefix);\n      }\n    } else if (p === 'list-style' || p === 'list-style-image' || p === 'content') {\n      if (prefix === '-webkit-' || prefix === '-webkit- old') {\n        return super.add(decl, prefix);\n      }\n    } else {\n      return super.add(decl, prefix);\n    }\n    return undefined;\n  }\n\n  /**\r\n   * Get div token from exists parameters\r\n   */\n  cloneDiv(params) {\n    for (let i of params) {\n      if (i.type === 'div' && i.value === ',') {\n        return i;\n      }\n    }\n    return {\n      after: ' ',\n      type: 'div',\n      value: ','\n    };\n  }\n\n  /**\r\n   * Change colors syntax to old webkit\r\n   */\n  colorStops(params) {\n    let result = [];\n    for (let i = 0; i < params.length; i++) {\n      let pos;\n      let param = params[i];\n      let item;\n      if (i === 0) {\n        continue;\n      }\n      let color = parser.stringify(param[0]);\n      if (param[1] && param[1].type === 'word') {\n        pos = param[1].value;\n      } else if (param[2] && param[2].type === 'word') {\n        pos = param[2].value;\n      }\n      let stop;\n      if (i === 1 && (!pos || pos === '0%')) {\n        stop = `from(${color})`;\n      } else if (i === params.length - 1 && (!pos || pos === '100%')) {\n        stop = `to(${color})`;\n      } else if (pos) {\n        stop = `color-stop(${pos}, ${color})`;\n      } else {\n        stop = `color-stop(${color})`;\n      }\n      let div = param[param.length - 1];\n      params[i] = [{\n        type: 'word',\n        value: stop\n      }];\n      if (div.type === 'div' && div.value === ',') {\n        item = params[i].push(div);\n      }\n      result.push(item);\n    }\n    return result;\n  }\n\n  /**\r\n   * Change new direction to old\r\n   */\n  convertDirection(params) {\n    if (params.length > 0) {\n      if (params[0].value === 'to') {\n        this.fixDirection(params);\n      } else if (params[0].value.includes('deg')) {\n        this.fixAngle(params);\n      } else if (this.isRadial(params)) {\n        this.fixRadial(params);\n      }\n    }\n    return params;\n  }\n\n  /**\r\n   * Add 90 degrees\r\n   */\n  fixAngle(params) {\n    let first = params[0].value;\n    first = parseFloat(first);\n    first = Math.abs(450 - first) % 360;\n    first = this.roundFloat(first, 3);\n    params[0].value = `${first}deg`;\n  }\n\n  /**\r\n   * Replace `to top left` to `bottom right`\r\n   */\n  fixDirection(params) {\n    params.splice(0, 2);\n    for (let param of params) {\n      if (param.type === 'div') {\n        break;\n      }\n      if (param.type === 'word') {\n        param.value = this.revertDirection(param.value);\n      }\n    }\n  }\n\n  /**\r\n   * Fix radial direction syntax\r\n   */\n  fixRadial(params) {\n    let first = [];\n    let second = [];\n    let a, b, c, i, next;\n    for (i = 0; i < params.length - 2; i++) {\n      a = params[i];\n      b = params[i + 1];\n      c = params[i + 2];\n      if (a.type === 'space' && b.value === 'at' && c.type === 'space') {\n        next = i + 3;\n        break;\n      } else {\n        first.push(a);\n      }\n    }\n    let div;\n    for (i = next; i < params.length; i++) {\n      if (params[i].type === 'div') {\n        div = params[i];\n        break;\n      } else {\n        second.push(params[i]);\n      }\n    }\n    params.splice(0, i, ...second, div, ...first);\n  }\n\n  /**\r\n   * Look for at word\r\n   */\n  isRadial(params) {\n    let state = 'before';\n    for (let param of params) {\n      if (state === 'before' && param.type === 'space') {\n        state = 'at';\n      } else if (state === 'at' && param.value === 'at') {\n        state = 'after';\n      } else if (state === 'after' && param.type === 'space') {\n        return true;\n      } else if (param.type === 'div') {\n        break;\n      } else {\n        state = 'before';\n      }\n    }\n    return false;\n  }\n\n  /**\r\n   * Replace old direction to new\r\n   */\n  newDirection(params) {\n    if (params[0].value === 'to') {\n      return params;\n    }\n    IS_DIRECTION.lastIndex = 0; // reset search index of global regexp\n    if (!IS_DIRECTION.test(params[0].value)) {\n      return params;\n    }\n    params.unshift({\n      type: 'word',\n      value: 'to'\n    }, {\n      type: 'space',\n      value: ' '\n    });\n    for (let i = 2; i < params.length; i++) {\n      if (params[i].type === 'div') {\n        break;\n      }\n      if (params[i].type === 'word') {\n        params[i].value = this.revertDirection(params[i].value);\n      }\n    }\n    return params;\n  }\n\n  /**\r\n   * Normalize angle\r\n   */\n  normalize(nodes, gradientName) {\n    if (!nodes[0]) return nodes;\n    if (/-?\\d+(.\\d+)?grad/.test(nodes[0].value)) {\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 400);\n    } else if (/-?\\d+(.\\d+)?rad/.test(nodes[0].value)) {\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI);\n    } else if (/-?\\d+(.\\d+)?turn/.test(nodes[0].value)) {\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 1);\n    } else if (nodes[0].value.includes('deg')) {\n      let num = parseFloat(nodes[0].value);\n      num = range.wrap(0, 360, num);\n      nodes[0].value = `${num}deg`;\n    }\n    if (gradientName === 'linear-gradient' || gradientName === 'repeating-linear-gradient') {\n      let direction = nodes[0].value;\n\n      // Unitless zero for `<angle>` values are allowed in CSS gradients and transforms.\n      // Spec: https://github.com/w3c/csswg-drafts/commit/602789171429b2231223ab1e5acf8f7f11652eb3\n      if (direction === '0deg' || direction === '0') {\n        nodes = this.replaceFirst(nodes, 'to', ' ', 'top');\n      } else if (direction === '90deg') {\n        nodes = this.replaceFirst(nodes, 'to', ' ', 'right');\n      } else if (direction === '180deg') {\n        nodes = this.replaceFirst(nodes, 'to', ' ', 'bottom'); // default value\n      } else if (direction === '270deg') {\n        nodes = this.replaceFirst(nodes, 'to', ' ', 'left');\n      }\n    }\n    return nodes;\n  }\n\n  /**\r\n   * Convert angle unit to deg\r\n   */\n  normalizeUnit(str, full) {\n    let num = parseFloat(str);\n    let deg = num / full * 360;\n    return `${deg}deg`;\n  }\n\n  /**\r\n   * Remove old WebKit gradient too\r\n   */\n  old(prefix) {\n    if (prefix === '-webkit-') {\n      let type;\n      if (this.name === 'linear-gradient') {\n        type = 'linear';\n      } else if (this.name === 'repeating-linear-gradient') {\n        type = 'repeating-linear';\n      } else if (this.name === 'repeating-radial-gradient') {\n        type = 'repeating-radial';\n      } else {\n        type = 'radial';\n      }\n      let string = '-gradient';\n      let regexp = utils.regexp(`-webkit-(${type}-gradient|gradient\\\\(\\\\s*${type})`, false);\n      return new OldValue(this.name, prefix + this.name, string, regexp);\n    } else {\n      return super.old(prefix);\n    }\n  }\n\n  /**\r\n   * Change direction syntax to old webkit\r\n   */\n  oldDirection(params) {\n    let div = this.cloneDiv(params[0]);\n    if (params[0][0].value !== 'to') {\n      return params.unshift([{\n        type: 'word',\n        value: Gradient.oldDirections.bottom\n      }, div]);\n    } else {\n      let words = [];\n      for (let node of params[0].slice(2)) {\n        if (node.type === 'word') {\n          words.push(node.value.toLowerCase());\n        }\n      }\n      words = words.join(' ');\n      let old = Gradient.oldDirections[words] || words;\n      params[0] = [{\n        type: 'word',\n        value: old\n      }, div];\n      return params[0];\n    }\n  }\n\n  /**\r\n   * Convert to old webkit syntax\r\n   */\n  oldWebkit(node) {\n    let {\n      nodes\n    } = node;\n    let string = parser.stringify(node.nodes);\n    if (this.name !== 'linear-gradient') {\n      return false;\n    }\n    if (nodes[0] && nodes[0].value.includes('deg')) {\n      return false;\n    }\n    if (string.includes('px') || string.includes('-corner') || string.includes('-side')) {\n      return false;\n    }\n    let params = [[]];\n    for (let i of nodes) {\n      params[params.length - 1].push(i);\n      if (i.type === 'div' && i.value === ',') {\n        params.push([]);\n      }\n    }\n    this.oldDirection(params);\n    this.colorStops(params);\n    node.nodes = [];\n    for (let param of params) {\n      node.nodes = node.nodes.concat(param);\n    }\n    node.nodes.unshift({\n      type: 'word',\n      value: 'linear'\n    }, this.cloneDiv(node.nodes));\n    node.value = '-webkit-gradient';\n    return true;\n  }\n\n  /**\r\n   * Change degrees for webkit prefix\r\n   */\n  replace(string, prefix) {\n    let ast = parser(string);\n    for (let node of ast.nodes) {\n      let gradientName = this.name; // gradient name\n      if (node.type === 'function' && node.value === gradientName) {\n        node.nodes = this.newDirection(node.nodes);\n        node.nodes = this.normalize(node.nodes, gradientName);\n        if (prefix === '-webkit- old') {\n          let changes = this.oldWebkit(node);\n          if (!changes) {\n            return false;\n          }\n        } else {\n          node.nodes = this.convertDirection(node.nodes);\n          node.value = prefix + node.value;\n        }\n      }\n    }\n    return ast.toString();\n  }\n\n  /**\r\n   * Replace first token\r\n   */\n  replaceFirst(params, ...words) {\n    let prefix = words.map(i => {\n      if (i === ' ') {\n        return {\n          type: 'space',\n          value: i\n        };\n      }\n      return {\n        type: 'word',\n        value: i\n      };\n    });\n    return prefix.concat(params.slice(1));\n  }\n  revertDirection(word) {\n    return Gradient.directions[word.toLowerCase()] || word;\n  }\n\n  /**\r\n   * Round float and save digits under dot\r\n   */\n  roundFloat(float, digits) {\n    return parseFloat(float.toFixed(digits));\n  }\n}\nGradient.names = ['linear-gradient', 'repeating-linear-gradient', 'radial-gradient', 'repeating-radial-gradient'];\nGradient.directions = {\n  bottom: 'top',\n  left: 'right',\n  right: 'left',\n  top: 'bottom' // default value\n};\n\n// Direction to replace\nGradient.oldDirections = {\n  'bottom': 'left top, left bottom',\n  'bottom left': 'right top, left bottom',\n  'bottom right': 'left top, right bottom',\n  'left': 'right top, left top',\n  'left bottom': 'right top, left bottom',\n  'left top': 'right bottom, left top',\n  'right': 'left top, right top',\n  'right bottom': 'left top, right bottom',\n  'right top': 'left bottom, right top',\n  'top': 'left bottom, left top',\n  'top left': 'right bottom, left top',\n  'top right': 'left bottom, right top'\n};\nmodule.exports = Gradient;","map":{"version":3,"names":["parser","require","range","OldValue","Value","utils","IS_DIRECTION","Gradient","add","decl","prefix","p","prop","includes","undefined","cloneDiv","params","i","type","value","after","colorStops","result","length","pos","param","item","color","stringify","stop","div","push","convertDirection","fixDirection","fixAngle","isRadial","fixRadial","first","parseFloat","Math","abs","roundFloat","splice","revertDirection","second","a","b","c","next","state","newDirection","lastIndex","test","unshift","normalize","nodes","gradientName","normalizeUnit","PI","num","wrap","direction","replaceFirst","str","full","deg","old","name","string","regexp","oldDirection","oldDirections","bottom","words","node","slice","toLowerCase","join","oldWebkit","concat","replace","ast","changes","toString","map","word","directions","float","digits","toFixed","names","left","right","top","module","exports"],"sources":["D:/SLIIT IT/Year 2 semster 2/ITP/Project/Smart TechHub Management System/New-Gen-/mern-admin/node_modules/autoprefixer/lib/hacks/gradient.js"],"sourcesContent":["let parser = require('postcss-value-parser')\r\nlet range = require('normalize-range')\r\n\r\nlet OldValue = require('../old-value')\r\nlet Value = require('../value')\r\nlet utils = require('../utils')\r\n\r\nlet IS_DIRECTION = /top|left|right|bottom/gi\r\n\r\nclass Gradient extends Value {\r\n  /**\r\n   * Do not add non-webkit prefixes for list-style and object\r\n   */\r\n  add(decl, prefix) {\r\n    let p = decl.prop\r\n    if (p.includes('mask')) {\r\n      if (prefix === '-webkit-' || prefix === '-webkit- old') {\r\n        return super.add(decl, prefix)\r\n      }\r\n    } else if (\r\n      p === 'list-style' ||\r\n      p === 'list-style-image' ||\r\n      p === 'content'\r\n    ) {\r\n      if (prefix === '-webkit-' || prefix === '-webkit- old') {\r\n        return super.add(decl, prefix)\r\n      }\r\n    } else {\r\n      return super.add(decl, prefix)\r\n    }\r\n    return undefined\r\n  }\r\n\r\n  /**\r\n   * Get div token from exists parameters\r\n   */\r\n  cloneDiv(params) {\r\n    for (let i of params) {\r\n      if (i.type === 'div' && i.value === ',') {\r\n        return i\r\n      }\r\n    }\r\n    return { after: ' ', type: 'div', value: ',' }\r\n  }\r\n\r\n  /**\r\n   * Change colors syntax to old webkit\r\n   */\r\n  colorStops(params) {\r\n    let result = []\r\n    for (let i = 0; i < params.length; i++) {\r\n      let pos\r\n      let param = params[i]\r\n      let item\r\n      if (i === 0) {\r\n        continue\r\n      }\r\n\r\n      let color = parser.stringify(param[0])\r\n      if (param[1] && param[1].type === 'word') {\r\n        pos = param[1].value\r\n      } else if (param[2] && param[2].type === 'word') {\r\n        pos = param[2].value\r\n      }\r\n\r\n      let stop\r\n      if (i === 1 && (!pos || pos === '0%')) {\r\n        stop = `from(${color})`\r\n      } else if (i === params.length - 1 && (!pos || pos === '100%')) {\r\n        stop = `to(${color})`\r\n      } else if (pos) {\r\n        stop = `color-stop(${pos}, ${color})`\r\n      } else {\r\n        stop = `color-stop(${color})`\r\n      }\r\n\r\n      let div = param[param.length - 1]\r\n      params[i] = [{ type: 'word', value: stop }]\r\n      if (div.type === 'div' && div.value === ',') {\r\n        item = params[i].push(div)\r\n      }\r\n      result.push(item)\r\n    }\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * Change new direction to old\r\n   */\r\n  convertDirection(params) {\r\n    if (params.length > 0) {\r\n      if (params[0].value === 'to') {\r\n        this.fixDirection(params)\r\n      } else if (params[0].value.includes('deg')) {\r\n        this.fixAngle(params)\r\n      } else if (this.isRadial(params)) {\r\n        this.fixRadial(params)\r\n      }\r\n    }\r\n    return params\r\n  }\r\n\r\n  /**\r\n   * Add 90 degrees\r\n   */\r\n  fixAngle(params) {\r\n    let first = params[0].value\r\n    first = parseFloat(first)\r\n    first = Math.abs(450 - first) % 360\r\n    first = this.roundFloat(first, 3)\r\n    params[0].value = `${first}deg`\r\n  }\r\n\r\n  /**\r\n   * Replace `to top left` to `bottom right`\r\n   */\r\n  fixDirection(params) {\r\n    params.splice(0, 2)\r\n\r\n    for (let param of params) {\r\n      if (param.type === 'div') {\r\n        break\r\n      }\r\n      if (param.type === 'word') {\r\n        param.value = this.revertDirection(param.value)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fix radial direction syntax\r\n   */\r\n  fixRadial(params) {\r\n    let first = []\r\n    let second = []\r\n    let a, b, c, i, next\r\n\r\n    for (i = 0; i < params.length - 2; i++) {\r\n      a = params[i]\r\n      b = params[i + 1]\r\n      c = params[i + 2]\r\n      if (a.type === 'space' && b.value === 'at' && c.type === 'space') {\r\n        next = i + 3\r\n        break\r\n      } else {\r\n        first.push(a)\r\n      }\r\n    }\r\n\r\n    let div\r\n    for (i = next; i < params.length; i++) {\r\n      if (params[i].type === 'div') {\r\n        div = params[i]\r\n        break\r\n      } else {\r\n        second.push(params[i])\r\n      }\r\n    }\r\n\r\n    params.splice(0, i, ...second, div, ...first)\r\n  }\r\n\r\n  /**\r\n   * Look for at word\r\n   */\r\n  isRadial(params) {\r\n    let state = 'before'\r\n    for (let param of params) {\r\n      if (state === 'before' && param.type === 'space') {\r\n        state = 'at'\r\n      } else if (state === 'at' && param.value === 'at') {\r\n        state = 'after'\r\n      } else if (state === 'after' && param.type === 'space') {\r\n        return true\r\n      } else if (param.type === 'div') {\r\n        break\r\n      } else {\r\n        state = 'before'\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Replace old direction to new\r\n   */\r\n  newDirection(params) {\r\n    if (params[0].value === 'to') {\r\n      return params\r\n    }\r\n    IS_DIRECTION.lastIndex = 0 // reset search index of global regexp\r\n    if (!IS_DIRECTION.test(params[0].value)) {\r\n      return params\r\n    }\r\n\r\n    params.unshift(\r\n      {\r\n        type: 'word',\r\n        value: 'to'\r\n      },\r\n      {\r\n        type: 'space',\r\n        value: ' '\r\n      }\r\n    )\r\n\r\n    for (let i = 2; i < params.length; i++) {\r\n      if (params[i].type === 'div') {\r\n        break\r\n      }\r\n      if (params[i].type === 'word') {\r\n        params[i].value = this.revertDirection(params[i].value)\r\n      }\r\n    }\r\n\r\n    return params\r\n  }\r\n\r\n  /**\r\n   * Normalize angle\r\n   */\r\n  normalize(nodes, gradientName) {\r\n    if (!nodes[0]) return nodes\r\n\r\n    if (/-?\\d+(.\\d+)?grad/.test(nodes[0].value)) {\r\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 400)\r\n    } else if (/-?\\d+(.\\d+)?rad/.test(nodes[0].value)) {\r\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI)\r\n    } else if (/-?\\d+(.\\d+)?turn/.test(nodes[0].value)) {\r\n      nodes[0].value = this.normalizeUnit(nodes[0].value, 1)\r\n    } else if (nodes[0].value.includes('deg')) {\r\n      let num = parseFloat(nodes[0].value)\r\n      num = range.wrap(0, 360, num)\r\n      nodes[0].value = `${num}deg`\r\n    }\r\n\r\n    if (\r\n      gradientName === 'linear-gradient' ||\r\n      gradientName === 'repeating-linear-gradient'\r\n    ) {\r\n      let direction = nodes[0].value\r\n\r\n      // Unitless zero for `<angle>` values are allowed in CSS gradients and transforms.\r\n      // Spec: https://github.com/w3c/csswg-drafts/commit/602789171429b2231223ab1e5acf8f7f11652eb3\r\n      if (direction === '0deg' || direction === '0') {\r\n        nodes = this.replaceFirst(nodes, 'to', ' ', 'top')\r\n      } else if (direction === '90deg') {\r\n        nodes = this.replaceFirst(nodes, 'to', ' ', 'right')\r\n      } else if (direction === '180deg') {\r\n        nodes = this.replaceFirst(nodes, 'to', ' ', 'bottom') // default value\r\n      } else if (direction === '270deg') {\r\n        nodes = this.replaceFirst(nodes, 'to', ' ', 'left')\r\n      }\r\n    }\r\n\r\n    return nodes\r\n  }\r\n\r\n  /**\r\n   * Convert angle unit to deg\r\n   */\r\n  normalizeUnit(str, full) {\r\n    let num = parseFloat(str)\r\n    let deg = (num / full) * 360\r\n    return `${deg}deg`\r\n  }\r\n\r\n  /**\r\n   * Remove old WebKit gradient too\r\n   */\r\n  old(prefix) {\r\n    if (prefix === '-webkit-') {\r\n      let type\r\n      if (this.name === 'linear-gradient') {\r\n        type = 'linear'\r\n      } else if (this.name === 'repeating-linear-gradient') {\r\n        type = 'repeating-linear'\r\n      } else if (this.name === 'repeating-radial-gradient') {\r\n        type = 'repeating-radial'\r\n      } else {\r\n        type = 'radial'\r\n      }\r\n      let string = '-gradient'\r\n      let regexp = utils.regexp(\r\n        `-webkit-(${type}-gradient|gradient\\\\(\\\\s*${type})`,\r\n        false\r\n      )\r\n\r\n      return new OldValue(this.name, prefix + this.name, string, regexp)\r\n    } else {\r\n      return super.old(prefix)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Change direction syntax to old webkit\r\n   */\r\n  oldDirection(params) {\r\n    let div = this.cloneDiv(params[0])\r\n\r\n    if (params[0][0].value !== 'to') {\r\n      return params.unshift([\r\n        { type: 'word', value: Gradient.oldDirections.bottom },\r\n        div\r\n      ])\r\n    } else {\r\n      let words = []\r\n      for (let node of params[0].slice(2)) {\r\n        if (node.type === 'word') {\r\n          words.push(node.value.toLowerCase())\r\n        }\r\n      }\r\n\r\n      words = words.join(' ')\r\n      let old = Gradient.oldDirections[words] || words\r\n\r\n      params[0] = [{ type: 'word', value: old }, div]\r\n      return params[0]\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert to old webkit syntax\r\n   */\r\n  oldWebkit(node) {\r\n    let { nodes } = node\r\n    let string = parser.stringify(node.nodes)\r\n\r\n    if (this.name !== 'linear-gradient') {\r\n      return false\r\n    }\r\n    if (nodes[0] && nodes[0].value.includes('deg')) {\r\n      return false\r\n    }\r\n    if (\r\n      string.includes('px') ||\r\n      string.includes('-corner') ||\r\n      string.includes('-side')\r\n    ) {\r\n      return false\r\n    }\r\n\r\n    let params = [[]]\r\n    for (let i of nodes) {\r\n      params[params.length - 1].push(i)\r\n      if (i.type === 'div' && i.value === ',') {\r\n        params.push([])\r\n      }\r\n    }\r\n\r\n    this.oldDirection(params)\r\n    this.colorStops(params)\r\n\r\n    node.nodes = []\r\n    for (let param of params) {\r\n      node.nodes = node.nodes.concat(param)\r\n    }\r\n\r\n    node.nodes.unshift(\r\n      { type: 'word', value: 'linear' },\r\n      this.cloneDiv(node.nodes)\r\n    )\r\n    node.value = '-webkit-gradient'\r\n\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Change degrees for webkit prefix\r\n   */\r\n  replace(string, prefix) {\r\n    let ast = parser(string)\r\n    for (let node of ast.nodes) {\r\n      let gradientName = this.name // gradient name\r\n      if (node.type === 'function' && node.value === gradientName) {\r\n        node.nodes = this.newDirection(node.nodes)\r\n        node.nodes = this.normalize(node.nodes, gradientName)\r\n        if (prefix === '-webkit- old') {\r\n          let changes = this.oldWebkit(node)\r\n          if (!changes) {\r\n            return false\r\n          }\r\n        } else {\r\n          node.nodes = this.convertDirection(node.nodes)\r\n          node.value = prefix + node.value\r\n        }\r\n      }\r\n    }\r\n    return ast.toString()\r\n  }\r\n\r\n  /**\r\n   * Replace first token\r\n   */\r\n  replaceFirst(params, ...words) {\r\n    let prefix = words.map(i => {\r\n      if (i === ' ') {\r\n        return { type: 'space', value: i }\r\n      }\r\n      return { type: 'word', value: i }\r\n    })\r\n    return prefix.concat(params.slice(1))\r\n  }\r\n\r\n  revertDirection(word) {\r\n    return Gradient.directions[word.toLowerCase()] || word\r\n  }\r\n\r\n  /**\r\n   * Round float and save digits under dot\r\n   */\r\n  roundFloat(float, digits) {\r\n    return parseFloat(float.toFixed(digits))\r\n  }\r\n}\r\n\r\nGradient.names = [\r\n  'linear-gradient',\r\n  'repeating-linear-gradient',\r\n  'radial-gradient',\r\n  'repeating-radial-gradient'\r\n]\r\n\r\nGradient.directions = {\r\n  bottom: 'top',\r\n  left: 'right',\r\n  right: 'left',\r\n  top: 'bottom' // default value\r\n}\r\n\r\n// Direction to replace\r\nGradient.oldDirections = {\r\n  'bottom': 'left top, left bottom',\r\n  'bottom left': 'right top, left bottom',\r\n  'bottom right': 'left top, right bottom',\r\n  'left': 'right top, left top',\r\n\r\n  'left bottom': 'right top, left bottom',\r\n  'left top': 'right bottom, left top',\r\n  'right': 'left top, right top',\r\n  'right bottom': 'left top, right bottom',\r\n  'right top': 'left bottom, right top',\r\n  'top': 'left bottom, left top',\r\n  'top left': 'right bottom, left top',\r\n  'top right': 'left bottom, right top'\r\n}\r\n\r\nmodule.exports = Gradient\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}