{"ast":null,"code":"let Declaration = require('../declaration');\nclass MaskComposite extends Declaration {\n  /**\r\n   * Prefix mask-composite for webkit\r\n   */\n  insert(decl, prefix, prefixes) {\n    let isCompositeProp = decl.prop === 'mask-composite';\n    let compositeValues;\n    if (isCompositeProp) {\n      compositeValues = decl.value.split(',');\n    } else {\n      compositeValues = decl.value.match(MaskComposite.regexp) || [];\n    }\n    compositeValues = compositeValues.map(el => el.trim()).filter(el => el);\n    let hasCompositeValues = compositeValues.length;\n    let compositeDecl;\n    if (hasCompositeValues) {\n      compositeDecl = this.clone(decl);\n      compositeDecl.value = compositeValues.map(value => MaskComposite.oldValues[value] || value).join(', ');\n      if (compositeValues.includes('intersect')) {\n        compositeDecl.value += ', xor';\n      }\n      compositeDecl.prop = prefix + 'mask-composite';\n    }\n    if (isCompositeProp) {\n      if (!hasCompositeValues) {\n        return undefined;\n      }\n      if (this.needCascade(decl)) {\n        compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix);\n      }\n      return decl.parent.insertBefore(decl, compositeDecl);\n    }\n    let cloned = this.clone(decl);\n    cloned.prop = prefix + cloned.prop;\n    if (hasCompositeValues) {\n      cloned.value = cloned.value.replace(MaskComposite.regexp, '');\n    }\n    if (this.needCascade(decl)) {\n      cloned.raws.before = this.calcBefore(prefixes, decl, prefix);\n    }\n    decl.parent.insertBefore(decl, cloned);\n    if (!hasCompositeValues) {\n      return decl;\n    }\n    if (this.needCascade(decl)) {\n      compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix);\n    }\n    return decl.parent.insertBefore(decl, compositeDecl);\n  }\n}\nMaskComposite.names = ['mask', 'mask-composite'];\nMaskComposite.oldValues = {\n  add: 'source-over',\n  exclude: 'xor',\n  intersect: 'source-in',\n  subtract: 'source-out'\n};\nMaskComposite.regexp = new RegExp(`\\\\s+(${Object.keys(MaskComposite.oldValues).join('|')})\\\\b(?!\\\\))\\\\s*(?=[,])`, 'ig');\nmodule.exports = MaskComposite;","map":{"version":3,"names":["Declaration","require","MaskComposite","insert","decl","prefix","prefixes","isCompositeProp","prop","compositeValues","value","split","match","regexp","map","el","trim","filter","hasCompositeValues","length","compositeDecl","clone","oldValues","join","includes","undefined","needCascade","raws","before","calcBefore","parent","insertBefore","cloned","replace","names","add","exclude","intersect","subtract","RegExp","Object","keys","module","exports"],"sources":["D:/SLIIT IT/Year 2 semster 2/ITP/Project/Smart TechHub Management System/New-Gen-/mern-admin/node_modules/autoprefixer/lib/hacks/mask-composite.js"],"sourcesContent":["let Declaration = require('../declaration')\r\n\r\nclass MaskComposite extends Declaration {\r\n  /**\r\n   * Prefix mask-composite for webkit\r\n   */\r\n  insert(decl, prefix, prefixes) {\r\n    let isCompositeProp = decl.prop === 'mask-composite'\r\n\r\n    let compositeValues\r\n\r\n    if (isCompositeProp) {\r\n      compositeValues = decl.value.split(',')\r\n    } else {\r\n      compositeValues = decl.value.match(MaskComposite.regexp) || []\r\n    }\r\n\r\n    compositeValues = compositeValues.map(el => el.trim()).filter(el => el)\r\n    let hasCompositeValues = compositeValues.length\r\n\r\n    let compositeDecl\r\n\r\n    if (hasCompositeValues) {\r\n      compositeDecl = this.clone(decl)\r\n      compositeDecl.value = compositeValues\r\n        .map(value => MaskComposite.oldValues[value] || value)\r\n        .join(', ')\r\n\r\n      if (compositeValues.includes('intersect')) {\r\n        compositeDecl.value += ', xor'\r\n      }\r\n\r\n      compositeDecl.prop = prefix + 'mask-composite'\r\n    }\r\n\r\n    if (isCompositeProp) {\r\n      if (!hasCompositeValues) {\r\n        return undefined\r\n      }\r\n\r\n      if (this.needCascade(decl)) {\r\n        compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix)\r\n      }\r\n\r\n      return decl.parent.insertBefore(decl, compositeDecl)\r\n    }\r\n\r\n    let cloned = this.clone(decl)\r\n    cloned.prop = prefix + cloned.prop\r\n\r\n    if (hasCompositeValues) {\r\n      cloned.value = cloned.value.replace(MaskComposite.regexp, '')\r\n    }\r\n\r\n    if (this.needCascade(decl)) {\r\n      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)\r\n    }\r\n\r\n    decl.parent.insertBefore(decl, cloned)\r\n\r\n    if (!hasCompositeValues) {\r\n      return decl\r\n    }\r\n\r\n    if (this.needCascade(decl)) {\r\n      compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix)\r\n    }\r\n    return decl.parent.insertBefore(decl, compositeDecl)\r\n  }\r\n}\r\n\r\nMaskComposite.names = ['mask', 'mask-composite']\r\n\r\nMaskComposite.oldValues = {\r\n  add: 'source-over',\r\n  exclude: 'xor',\r\n  intersect: 'source-in',\r\n  subtract: 'source-out'\r\n}\r\n\r\nMaskComposite.regexp = new RegExp(\r\n  `\\\\s+(${Object.keys(MaskComposite.oldValues).join(\r\n    '|'\r\n  )})\\\\b(?!\\\\))\\\\s*(?=[,])`,\r\n  'ig'\r\n)\r\n\r\nmodule.exports = MaskComposite\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}