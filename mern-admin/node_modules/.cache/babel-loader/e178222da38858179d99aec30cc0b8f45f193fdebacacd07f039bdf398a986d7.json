{"ast":null,"code":"class OldSelector {\n  constructor(selector, prefix) {\n    this.prefix = prefix;\n    this.prefixed = selector.prefixed(this.prefix);\n    this.regexp = selector.regexp(this.prefix);\n    this.prefixeds = selector.possible().map(x => [selector.prefixed(x), selector.regexp(x)]);\n    this.unprefixed = selector.name;\n    this.nameRegexp = selector.regexp();\n  }\n\n  /**\r\n   * Does rule contain an unnecessary prefixed selector\r\n   */\n  check(rule) {\n    if (!rule.selector.includes(this.prefixed)) {\n      return false;\n    }\n    if (!rule.selector.match(this.regexp)) {\n      return false;\n    }\n    if (this.isHack(rule)) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\r\n   * Is rule a hack without unprefixed version bottom\r\n   */\n  isHack(rule) {\n    let index = rule.parent.index(rule) + 1;\n    let rules = rule.parent.nodes;\n    while (index < rules.length) {\n      let before = rules[index].selector;\n      if (!before) {\n        return true;\n      }\n      if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {\n        return false;\n      }\n      let some = false;\n      for (let [string, regexp] of this.prefixeds) {\n        if (before.includes(string) && before.match(regexp)) {\n          some = true;\n          break;\n        }\n      }\n      if (!some) {\n        return true;\n      }\n      index += 1;\n    }\n    return true;\n  }\n}\nmodule.exports = OldSelector;","map":{"version":3,"names":["OldSelector","constructor","selector","prefix","prefixed","regexp","prefixeds","possible","map","x","unprefixed","name","nameRegexp","check","rule","includes","match","isHack","index","parent","rules","nodes","length","before","some","string","module","exports"],"sources":["D:/SLIIT IT/Year 2 semster 2/ITP/Project/Smart TechHub Management System/New-Gen-/mern-admin/node_modules/autoprefixer/lib/old-selector.js"],"sourcesContent":["class OldSelector {\r\n  constructor(selector, prefix) {\r\n    this.prefix = prefix\r\n    this.prefixed = selector.prefixed(this.prefix)\r\n    this.regexp = selector.regexp(this.prefix)\r\n\r\n    this.prefixeds = selector\r\n      .possible()\r\n      .map(x => [selector.prefixed(x), selector.regexp(x)])\r\n\r\n    this.unprefixed = selector.name\r\n    this.nameRegexp = selector.regexp()\r\n  }\r\n\r\n  /**\r\n   * Does rule contain an unnecessary prefixed selector\r\n   */\r\n  check(rule) {\r\n    if (!rule.selector.includes(this.prefixed)) {\r\n      return false\r\n    }\r\n    if (!rule.selector.match(this.regexp)) {\r\n      return false\r\n    }\r\n    if (this.isHack(rule)) {\r\n      return false\r\n    }\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Is rule a hack without unprefixed version bottom\r\n   */\r\n  isHack(rule) {\r\n    let index = rule.parent.index(rule) + 1\r\n    let rules = rule.parent.nodes\r\n\r\n    while (index < rules.length) {\r\n      let before = rules[index].selector\r\n      if (!before) {\r\n        return true\r\n      }\r\n\r\n      if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {\r\n        return false\r\n      }\r\n\r\n      let some = false\r\n      for (let [string, regexp] of this.prefixeds) {\r\n        if (before.includes(string) && before.match(regexp)) {\r\n          some = true\r\n          break\r\n        }\r\n      }\r\n\r\n      if (!some) {\r\n        return true\r\n      }\r\n\r\n      index += 1\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\nmodule.exports = OldSelector\r\n"],"mappings":"AAAA,MAAMA,WAAW,CAAC;EAChBC,WAAWA,CAACC,QAAQ,EAAEC,MAAM,EAAE;IAC5B,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,QAAQ,GAAGF,QAAQ,CAACE,QAAQ,CAAC,IAAI,CAACD,MAAM,CAAC;IAC9C,IAAI,CAACE,MAAM,GAAGH,QAAQ,CAACG,MAAM,CAAC,IAAI,CAACF,MAAM,CAAC;IAE1C,IAAI,CAACG,SAAS,GAAGJ,QAAQ,CACtBK,QAAQ,CAAC,CAAC,CACVC,GAAG,CAACC,CAAC,IAAI,CAACP,QAAQ,CAACE,QAAQ,CAACK,CAAC,CAAC,EAAEP,QAAQ,CAACG,MAAM,CAACI,CAAC,CAAC,CAAC,CAAC;IAEvD,IAAI,CAACC,UAAU,GAAGR,QAAQ,CAACS,IAAI;IAC/B,IAAI,CAACC,UAAU,GAAGV,QAAQ,CAACG,MAAM,CAAC,CAAC;EACrC;;EAEA;AACF;AACA;EACEQ,KAAKA,CAACC,IAAI,EAAE;IACV,IAAI,CAACA,IAAI,CAACZ,QAAQ,CAACa,QAAQ,CAAC,IAAI,CAACX,QAAQ,CAAC,EAAE;MAC1C,OAAO,KAAK;IACd;IACA,IAAI,CAACU,IAAI,CAACZ,QAAQ,CAACc,KAAK,CAAC,IAAI,CAACX,MAAM,CAAC,EAAE;MACrC,OAAO,KAAK;IACd;IACA,IAAI,IAAI,CAACY,MAAM,CAACH,IAAI,CAAC,EAAE;MACrB,OAAO,KAAK;IACd;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACEG,MAAMA,CAACH,IAAI,EAAE;IACX,IAAII,KAAK,GAAGJ,IAAI,CAACK,MAAM,CAACD,KAAK,CAACJ,IAAI,CAAC,GAAG,CAAC;IACvC,IAAIM,KAAK,GAAGN,IAAI,CAACK,MAAM,CAACE,KAAK;IAE7B,OAAOH,KAAK,GAAGE,KAAK,CAACE,MAAM,EAAE;MAC3B,IAAIC,MAAM,GAAGH,KAAK,CAACF,KAAK,CAAC,CAAChB,QAAQ;MAClC,IAAI,CAACqB,MAAM,EAAE;QACX,OAAO,IAAI;MACb;MAEA,IAAIA,MAAM,CAACR,QAAQ,CAAC,IAAI,CAACL,UAAU,CAAC,IAAIa,MAAM,CAACP,KAAK,CAAC,IAAI,CAACJ,UAAU,CAAC,EAAE;QACrE,OAAO,KAAK;MACd;MAEA,IAAIY,IAAI,GAAG,KAAK;MAChB,KAAK,IAAI,CAACC,MAAM,EAAEpB,MAAM,CAAC,IAAI,IAAI,CAACC,SAAS,EAAE;QAC3C,IAAIiB,MAAM,CAACR,QAAQ,CAACU,MAAM,CAAC,IAAIF,MAAM,CAACP,KAAK,CAACX,MAAM,CAAC,EAAE;UACnDmB,IAAI,GAAG,IAAI;UACX;QACF;MACF;MAEA,IAAI,CAACA,IAAI,EAAE;QACT,OAAO,IAAI;MACb;MAEAN,KAAK,IAAI,CAAC;IACZ;IAEA,OAAO,IAAI;EACb;AACF;AAEAQ,MAAM,CAACC,OAAO,GAAG3B,WAAW","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}