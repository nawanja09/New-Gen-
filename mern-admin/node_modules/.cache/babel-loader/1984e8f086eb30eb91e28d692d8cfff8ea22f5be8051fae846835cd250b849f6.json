{"ast":null,"code":"var Query = require('./queries');\nvar Operator = require('./operators');\nvar NUMBERS = /[0-9]/;\nvar LETTERS = /[a-z|\\-]/i;\nvar WHITESPACE = /\\s/;\nvar COLON = /:/;\nvar COMMA = /,/;\nvar AND = /and$/;\nvar AT = /@/;\nfunction tokenizer(input) {\n  var current = 0;\n  var tokens = [];\n  while (current < input.length) {\n    var char = input[current];\n    if (AT.test(char)) {\n      char = input[++current];\n      while (LETTERS.test(char) && char !== undefined) {\n        char = input[++current];\n      }\n    }\n    if (WHITESPACE.test(char) || char === ')' || char === '(') {\n      current++;\n      continue;\n    }\n    if (COLON.test(char) || COMMA.test(char)) {\n      current++;\n      tokens.push({\n        type: 'operator',\n        value: char\n      });\n      continue;\n    }\n    if (NUMBERS.test(char)) {\n      var value = '';\n      while (NUMBERS.test(char)) {\n        value += char;\n        char = input[++current];\n      }\n      tokens.push({\n        type: 'number',\n        value: value\n      });\n      continue;\n    }\n    if (LETTERS.test(char)) {\n      var value = '';\n      while (LETTERS.test(char) && char !== undefined) {\n        value += char;\n        char = input[++current];\n      }\n      if (AND.test(value)) {\n        tokens.push({\n          type: 'operator',\n          value: value\n        });\n      } else {\n        tokens.push({\n          type: 'literal',\n          value: value\n        });\n      }\n      continue;\n    }\n    throw new TypeError('Tokenizer: I dont know what this character is: ' + char);\n  }\n  return tokens;\n}\nfunction parser(tokens) {\n  var output = [];\n  var stack = [];\n  while (tokens.length > 0) {\n    var token = tokens.shift();\n    if (token.type === 'number' || token.type === 'literal') {\n      output.push(token);\n      continue;\n    }\n    if (token.type === 'operator') {\n      if (COLON.test(token.value)) {\n        token = {\n          type: 'query',\n          key: output.pop(),\n          value: tokens.shift()\n        };\n        output.push(token);\n        continue;\n      }\n      while (stack.length > 0) {\n        output.unshift(stack.pop());\n      }\n      stack.push(token);\n    }\n  }\n  while (stack.length > 0) {\n    output.unshift(stack.pop());\n  }\n  function walk() {\n    var head = output.shift();\n    if (head.type === 'number') {\n      return parseInt(head.value);\n    }\n    if (head.type === 'literal') {\n      return head.value;\n    }\n    if (head.type === 'operator') {\n      var l = walk();\n      var r = walk();\n      return Operator(head.value, l, r);\n    }\n    if (head.type === 'query') {\n      var l = head.key.value;\n      var r = head.value.value;\n      return Query(l, r);\n    }\n  }\n  return walk();\n}\nmodule.exports = {\n  parse: function (query) {\n    var tokens = tokenizer(query);\n    var ast = parser(tokens);\n    return ast;\n  }\n};","map":{"version":3,"names":["Query","require","Operator","NUMBERS","LETTERS","WHITESPACE","COLON","COMMA","AND","AT","tokenizer","input","current","tokens","length","char","test","undefined","push","type","value","TypeError","parser","output","stack","token","shift","key","pop","unshift","walk","head","parseInt","l","r","module","exports","parse","query","ast"],"sources":["D:/SLIIT IT/Year 2 semster 2/ITP/Project/Smart TechHub Management System/New-Gen-/mern-admin/node_modules/media-engine/src/parser.js"],"sourcesContent":["var Query = require('./queries');\r\nvar Operator = require('./operators');\r\n\r\nvar NUMBERS = /[0-9]/;\r\nvar LETTERS = /[a-z|\\-]/i;\r\nvar WHITESPACE = /\\s/;\r\nvar COLON = /:/;\r\nvar COMMA = /,/;\r\nvar AND = /and$/;\r\nvar AT = /@/;\r\n\r\nfunction tokenizer(input) {\r\n  var current = 0;\r\n  var tokens = [];\r\n\r\n  while (current < input.length) {\r\n    var char = input[current];\r\n\r\n    if (AT.test(char)) {\r\n      char = input[++current];\r\n      while (LETTERS.test(char) && char !== undefined) {\r\n        char = input[++current];\r\n      }\r\n    }\r\n\r\n    if (WHITESPACE.test(char) || char === ')' || char === '(') {\r\n      current++;\r\n      continue;\r\n    }\r\n\r\n    if (COLON.test(char) || COMMA.test(char)) {\r\n      current++;\r\n      tokens.push({ type: 'operator', value: char });\r\n      continue;\r\n    }\r\n\r\n    if (NUMBERS.test(char)) {\r\n      var value = '';\r\n      while (NUMBERS.test(char)) {\r\n        value += char;\r\n        char = input[++current];\r\n      }\r\n\r\n      tokens.push({ type: 'number', value: value });\r\n      continue;\r\n    }\r\n\r\n    if (LETTERS.test(char)) {\r\n      var value = '';\r\n      while (LETTERS.test(char) && char !== undefined) {\r\n        value += char;\r\n        char = input[++current];\r\n      }\r\n      if (AND.test(value)) {\r\n        tokens.push({ type: 'operator', value: value });\r\n      } else {\r\n        tokens.push({ type: 'literal', value: value });\r\n      }\r\n\r\n      continue;\r\n    }\r\n\r\n    throw new TypeError(\r\n      'Tokenizer: I dont know what this character is: ' + char\r\n    );\r\n  }\r\n\r\n  return tokens;\r\n}\r\n\r\nfunction parser(tokens) {\r\n  var output = [];\r\n  var stack = [];\r\n\r\n  while (tokens.length > 0) {\r\n    var token = tokens.shift();\r\n\r\n    if (token.type === 'number' || token.type === 'literal') {\r\n      output.push(token);\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'operator') {\r\n      if (COLON.test(token.value)) {\r\n        token = { type: 'query', key: output.pop(), value: tokens.shift() };\r\n        output.push(token);\r\n        continue;\r\n      }\r\n\r\n      while (stack.length > 0) {\r\n        output.unshift(stack.pop());\r\n      }\r\n      stack.push(token);\r\n    }\r\n  }\r\n\r\n  while (stack.length > 0) {\r\n    output.unshift(stack.pop());\r\n  }\r\n\r\n  function walk() {\r\n    var head = output.shift();\r\n\r\n    if (head.type === 'number') {\r\n      return parseInt(head.value);\r\n    }\r\n\r\n    if (head.type === 'literal') {\r\n      return head.value;\r\n    }\r\n\r\n    if (head.type === 'operator') {\r\n      var l = walk();\r\n      var r = walk();\r\n\r\n      return Operator(head.value, l, r);\r\n    }\r\n\r\n    if (head.type === 'query') {\r\n      var l = head.key.value;\r\n      var r = head.value.value;\r\n\r\n      return Query(l, r);\r\n    }\r\n  }\r\n\r\n  return walk();\r\n}\r\n\r\nmodule.exports = {\r\n  parse: function(query) {\r\n    var tokens = tokenizer(query);\r\n    var ast = parser(tokens);\r\n    return ast;\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}