{"ast":null,"code":"import { isNil, last, repeat, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\nimport _extends from '@babel/runtime/helpers/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\nimport bidiFactory from 'bidi-js';\nimport _createForOfIteratorHelperLoose from '@babel/runtime/helpers/createForOfIteratorHelperLoose';\nimport unicode from 'unicode-properties';\nimport hyphen from 'hyphen';\nimport pattern from 'hyphen/patterns/en-us.js';\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Fragment} Fragment\r\n */\n\n/**\r\n * Create attributed string from text fragments\r\n *\r\n * @param {Fragment[]} fragments fragments\r\n * @returns {AttributedString} attributed string\r\n */\nvar fromFragments = function fromFragments(fragments) {\n  var offset = 0;\n  var string = '';\n  var runs = [];\n  fragments.forEach(function (fragment) {\n    string += fragment.string;\n    runs.push(_extends({}, fragment, {\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    }));\n    offset += fragment.string.length;\n  });\n  return {\n    string: string,\n    runs: runs\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Default word hyphenation engine used when no one provided.\r\n * Does not perform word hyphenation at all\r\n *\r\n * @param {string} word\r\n * @returns {[string]} same word\r\n */\nvar defaultHyphenationEngine = function defaultHyphenationEngine(word) {\n  return [word];\n};\n\n/**\r\n * Wrap words of attribute string\r\n *\r\n * @param {Object} engines layout engines\r\n * @param {Object} options layout options\r\n */\nvar wrapWords = function wrapWords(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string including syllables\r\n   */\n  return function (attributedString) {\n    var _engines$wordHyphenat, _engines;\n    var syllables = [];\n    var fragments = [];\n    var hyphenateWord = options.hyphenationCallback || ((_engines$wordHyphenat = (_engines = engines).wordHyphenation) === null || _engines$wordHyphenat === void 0 ? void 0 : _engines$wordHyphenat.call(_engines, options)) || defaultHyphenationEngine;\n    for (var i = 0; i < attributedString.runs.length; i += 1) {\n      var string = '';\n      var run = attributedString.runs[i];\n      var words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\n      for (var j = 0; j < words.length; j += 1) {\n        var word = words[j];\n        var parts = hyphenateWord(word);\n        syllables.push.apply(syllables, parts);\n        string += parts.join('');\n      }\n      fragments.push(_extends({}, run, {\n        string: string\n      }));\n    }\n    return _extends({}, fromFragments(fragments), {\n      syllables: syllables\n    });\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\n\n/**\r\n * Clone rect\r\n *\r\n * @param {Rect} rect rect\r\n * @returns {Rect} cloned rect\r\n */\nvar copy = function copy(rect) {\n  return Object.assign({}, rect);\n};\n\n/**\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\n\n/**\r\n *\r\n * @param {Rect} rect rect\r\n * @param {number} height height\r\n * @returns {[Rect, Rect]} partitioned rects\r\n */\nvar partition = function partition(rect, height) {\n  var a = Object.assign({}, rect, {\n    height: height\n  });\n  var b = Object.assign({}, rect, {\n    y: rect.y + height,\n    height: rect.height - height\n  });\n  return [a, b];\n};\n\n/**\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\n\n/**\r\n * Crop upper section of rect\r\n *\r\n * @param {number} height height\r\n * @param {Rect} rect rect\r\n * @returns {Rect} cropped rect\r\n */\nvar crop = function crop(height, rect) {\n  var _partition = partition(rect, height),\n    result = _partition[1];\n  return result;\n};\n\n/**\r\n * Get paragraph block height\r\n *\r\n * @param {Object}  paragraph block\r\n * @returns {number} paragraph block height\r\n */\nvar height$2 = function height(paragraph) {\n  return paragraph.reduce(function (acc, block) {\n    return acc + block.box.height;\n  }, 0);\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Calculate run scale\r\n *\r\n * @param {Run} run run\r\n * @returns {number} scale\r\n */\nvar calculateScale = function calculateScale(run) {\n  var _attributes$font;\n  var attributes = run.attributes || {};\n  var fontSize = attributes.fontSize || 12;\n  var unitsPerEm = (_attributes$font = attributes.font) === null || _attributes$font === void 0 ? void 0 : _attributes$font.unitsPerEm;\n  return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n\n/**\r\n * Get run scale\r\n *\r\n * @param {Object}  run\r\n * @returns {number} scale\r\n */\nvar scale = function scale(run) {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.scale) || calculateScale(run);\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Get ligature offset by index\r\n *\r\n * Ex. ffi ligature\r\n *\r\n *   glyphs:         l  o  f  f  i  m\r\n *   glyphIndices:   0  1  2  2  2  3\r\n *   offset:         0  0  0  1  2  0\r\n *\r\n * @param {number} index\r\n * @param {Run} run run\r\n * @returns {number} ligature offset\r\n */\nvar offset = function offset(index, run) {\n  if (!run) return 0;\n  var glyphIndices = run.glyphIndices || [];\n  var value = glyphIndices[index];\n  return glyphIndices.slice(0, index).filter(function (i) {\n    return i === value;\n  }).length;\n};\n\n/**\r\n * @typedef {import('../types.js').Font} Font\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Get run font\r\n *\r\n * @param {Run} run run\r\n * @returns {Font | null} font\r\n */\nvar getFont = function getFont(run) {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.font) || null;\n};\n\n/**\r\n * @typedef {import('../types.js').Font} Font\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n */\n\n/**\r\n * Slice glyph between codePoints range\r\n * Util for breaking ligatures\r\n *\r\n * @param {number} start start code point index\r\n * @param {number} end end code point index\r\n * @param {Font} font font to generate new glyph\r\n * @param {Glyph} glyph glyph to be sliced\r\n * @returns {Glyph[]} sliced glyph parts\r\n */\nvar slice$2 = function slice(start, end, font, glyph) {\n  if (!glyph) return [];\n  if (start === end) return [];\n  if (start === 0 && end === glyph.codePoints.length) return [glyph];\n  var codePoints = glyph.codePoints.slice(start, end);\n  var string = String.fromCodePoint.apply(String, codePoints);\n\n  // passing LTR To force fontkit to not reverse the string\n  return font ? font.layout(string, undefined, undefined, undefined, 'ltr').glyphs : [glyph];\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Return glyph index at string index, if glyph indices present.\r\n * Otherwise return string index\r\n *\r\n * @param {number} index index\r\n * @param {Run} run run\r\n * @returns {number} glyph index\r\n */\nvar glyphIndexAt = function glyphIndexAt(index, run) {\n  var _run$glyphIndices;\n  var result = run === null || run === void 0 ? void 0 : (_run$glyphIndices = run.glyphIndices) === null || _run$glyphIndices === void 0 ? void 0 : _run$glyphIndices[index];\n  return isNil(result) ? index : result;\n};\n\n/**\r\n * Returns new array starting with zero, and keeping same relation between consecutive values\r\n *\r\n * @param {number[]} array list\r\n * @returns {number[]} normalized array\r\n */\nvar normalize = function normalize(array) {\n  var head = array[0];\n  return array.map(function (value) {\n    return value - head;\n  });\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Slice run between glyph indices range\r\n *\r\n * @param {number} start glyph index\r\n * @param {number} end glyph index\r\n * @param {Run} run run\r\n * @returns {Run} sliced run\r\n */\nvar slice$1 = function slice(start, end, run) {\n  var _run$glyphs, _run$glyphs2;\n  var runScale = scale(run);\n  var font = getFont(run);\n\n  // Get glyph start and end indices\n  var startIndex = glyphIndexAt(start, run);\n  var endIndex = glyphIndexAt(end, run);\n\n  // Get start and end glyph\n  var startGlyph = (_run$glyphs = run.glyphs) === null || _run$glyphs === void 0 ? void 0 : _run$glyphs[startIndex];\n  var endGlyph = (_run$glyphs2 = run.glyphs) === null || _run$glyphs2 === void 0 ? void 0 : _run$glyphs2[endIndex];\n\n  // Get start ligature chunks (if any)\n  var startOffset = offset(start, run);\n  var startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];\n\n  // Get end ligature chunks (if any)\n  var endOffset = offset(end, run);\n  var endGlyphs = slice$2(0, endOffset, font, endGlyph);\n\n  // Compute new glyphs\n  var sliceStart = startIndex + Math.min(1, startOffset);\n  var glyphs = (run.glyphs || []).slice(sliceStart, endIndex);\n\n  // Compute new positions\n  var glyphPosition = function glyphPosition(g) {\n    return {\n      xAdvance: g.advanceWidth * runScale\n    };\n  };\n  var startPositions = startGlyphs.map(glyphPosition);\n  var positions = (run.positions || []).slice(sliceStart, endIndex);\n  var endPositions = endGlyphs.map(glyphPosition);\n  return Object.assign({}, run, {\n    start: run.start + start,\n    end: Math.min(run.end, run.start + end),\n    glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n    positions: [startPositions, positions, endPositions].flat()\n  });\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Get run index that contains passed index\r\n *\r\n * @param {number} n index\r\n * @param {Run[]} runs runs\r\n * @returns {number} run index\r\n */\nvar runIndexAt$1 = function runIndexAt(n, runs) {\n  if (!runs) return -1;\n  return runs.findIndex(function (run) {\n    return run.start <= n && n < run.end;\n  });\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Filter runs contained between start and end\r\n *\r\n * @param {number} start\r\n * @param {number} end\r\n * @param {Run[]} runs\r\n * @returns {Run[]} filtered runs\r\n */\nvar filter = function filter(start, end, runs) {\n  var startIndex = runIndexAt$1(start, runs);\n  var endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n  return runs.slice(startIndex, endIndex + 1);\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Subtract scalar to run\r\n *\r\n * @param {number} n scalar\r\n * @param {Run} run run\r\n * @returns {Object} subtracted run\r\n */\nvar subtract = function subtract(n, run) {\n  var start = run.start - n;\n  var end = run.end - n;\n  return Object.assign({}, run, {\n    start: start,\n    end: end\n  });\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Slice array of runs\r\n *\r\n * @param {number} start offset\r\n * @param {number} end offset\r\n * @param {Run[]} runs\r\n * @returns {Run[]} sliced runs\r\n */\nvar sliceRuns = function sliceRuns(start, end, runs) {\n  var sliceFirstRun = function sliceFirstRun(a) {\n    return slice$1(start - a.start, end - a.start, a);\n  };\n  var sliceLastRun = function sliceLastRun(a) {\n    return slice$1(0, end - a.start, a);\n  };\n  return runs.map(function (run, i) {\n    var result = run;\n    var isFirst = i === 0;\n    var isLast = !isFirst && i === runs.length - 1;\n    if (isFirst) result = sliceFirstRun(run);\n    if (isLast) result = sliceLastRun(run);\n    return subtract(start, result);\n  });\n};\n\n/**\r\n * Slice attributed string between two indices\r\n *\r\n * @param {number} start offset\r\n * @param {number} end offset\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {AttributedString} attributed string\r\n */\nvar slice = function slice(start, end, attributedString) {\n  if (attributedString.string.length === 0) return attributedString;\n  var string = attributedString.string.slice(start, end);\n  var filteredRuns = filter(start, end, attributedString.runs);\n  var slicedRuns = sliceRuns(start, end, filteredRuns);\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: slicedRuns\n  });\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * @param {string} string\r\n * @returns {number} index\r\n */\nvar findCharIndex = function findCharIndex(string) {\n  return string.search(/\\S/g);\n};\n\n/**\r\n * @param {string} string\r\n * @returns {number} index\r\n */\nvar findLastCharIndex = function findLastCharIndex(string) {\n  var match = string.match(/\\S/g);\n  return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n\n/**\r\n * Removes (strips) whitespace from both ends of the attributted string.\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {AttributedString} attributed string\r\n */\nvar trim = function trim(attributedString) {\n  var start = findCharIndex(attributedString.string);\n  var end = findLastCharIndex(attributedString.string);\n  return slice(start, end + 1, attributedString);\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Returns empty run\r\n *\r\n * @returns {Run} empty run\r\n */\nvar empty$1 = function empty() {\n  return {\n    start: 0,\n    end: 0,\n    glyphIndices: [],\n    glyphs: [],\n    positions: [],\n    attributes: {}\n  };\n};\n\n/**\r\n * Check if value is a number\r\n *\r\n * @template {unknown} T\r\n * @param {T} value Value to check\r\n * @returns {value is number} Whether value is a number\r\n */\nvar isNumber = function isNumber(value) {\n  return typeof value === 'number';\n};\n\n/**\r\n * Append glyph indices with given length\r\n *\r\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\r\n *\r\n * @param {number} length length\r\n * @param {number[]} indices glyph indices\r\n * @returns {number[]} extended glyph indices\r\n */\nvar appendIndices = function appendIndices(length, indices) {\n  var lastIndex = last(indices);\n  var value = isNil(lastIndex) ? 0 : lastIndex + 1;\n  var newIndices = Array(length).fill(value);\n  return indices.concat(newIndices);\n};\n\n/**\r\n * @typedef {import('../types.js').Font} Font\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n */\n\n/**\r\n * Get glyph for a given code point\r\n *\r\n * @param {number} [value] codePoint\r\n * @param {Font} [font] font\r\n * @returns {Glyph} glyph\r\n * */\nvar fromCodePoint = function fromCodePoint(value, font) {\n  return font && value ? font.glyphForCodePoint(value) : null;\n};\n\n/**\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Append glyph to run\r\n *\r\n * @param {Glyph} glyph glyph\r\n * @param {Run} run run\r\n * @returns {Run} run with glyph\r\n */\nvar appendGlyph = function appendGlyph(glyph, run) {\n  var _glyph$codePoints;\n  var glyphLength = ((_glyph$codePoints = glyph.codePoints) === null || _glyph$codePoints === void 0 ? void 0 : _glyph$codePoints.length) || 0;\n  var end = run.end + glyphLength;\n  var glyphs = run.glyphs.concat(glyph);\n  var glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n  if (!run.positions) return Object.assign({}, run, {\n    end: end,\n    glyphs: glyphs,\n    glyphIndices: glyphIndices\n  });\n  var positions = run.positions.concat({\n    xAdvance: glyph.advanceWidth * scale(run)\n  });\n  return Object.assign({}, run, {\n    end: end,\n    glyphs: glyphs,\n    glyphIndices: glyphIndices,\n    positions: positions\n  });\n};\n\n/**\r\n * Append glyph or code point to run\r\n *\r\n * @param {Glyph | number | undefined} value glyph or codePoint\r\n * @param {Run} run run\r\n * @returns {Run} run with glyph\r\n */\nvar append$1 = function append(value, run) {\n  if (!value) return run;\n  var font = getFont(run);\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return appendGlyph(glyph, run);\n};\n\n/**\r\n * Get string from array of code points\r\n *\r\n * @param {number[]} codePoints points\r\n * @returns {string} string\r\n */\nvar stringFromCodePoints = function stringFromCodePoints(codePoints) {\n  return String.fromCodePoint.apply(String, codePoints || []);\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n */\n\n/**\r\n * Append glyph into last run of attributed string\r\n *\r\n * @param {Glyph} glyph glyph\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {AttributedString} attributed string with new glyph\r\n */\nvar append = function append(glyph, attributedString) {\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  var codePointsString = stringFromCodePoints(codePoints);\n  var string = attributedString.string + codePointsString;\n  var firstRuns = attributedString.runs.slice(0, -1);\n  var lastRun = last(attributedString.runs) || empty$1();\n  var runs = firstRuns.concat(append$1(glyph, lastRun));\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\nvar ELLIPSIS_UNICODE = 8230;\nvar ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n\n/**\r\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\r\n *\r\n * @param {Object} font\r\n * @returns {Object} ellipsis codepoint\r\n */\nvar getEllipsisCodePoint = function getEllipsisCodePoint(font) {\n  if (!font.encode) return ELLIPSIS_UNICODE;\n  var _font$encode = font.encode(ELLIPSIS_STRING),\n    codePoints = _font$encode[0];\n  return parseInt(codePoints[0], 16);\n};\n\n/**\r\n * Trucante block with ellipsis\r\n *\r\n * @param {Object} block paragraph block\r\n * @returns {Object} sliced paragraph block\r\n */\nvar truncate = function truncate(block) {\n  var _last, _last2, _last2$attributes;\n  var runs = ((_last = last(block)) === null || _last === void 0 ? void 0 : _last.runs) || [];\n  var font = (_last2 = last(runs)) === null || _last2 === void 0 ? void 0 : (_last2$attributes = _last2.attributes) === null || _last2$attributes === void 0 ? void 0 : _last2$attributes.font;\n  if (font) {\n    var _Object$assign;\n    var index = block.length - 1;\n    var codePoint = getEllipsisCodePoint(font);\n    var glyph = font.glyphForCodePoint(codePoint);\n    var lastBlock = append(glyph, trim(block[index]));\n    return Object.assign([], block, (_Object$assign = {}, _Object$assign[index] = lastBlock, _Object$assign));\n  }\n  return block;\n};\n\n/**\r\n * @typedef {import('../types.js').Attributes} Attributes\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Omit attribute from run\r\n *\r\n * @param {keyof Attributes} value attribute value\r\n * @param {Run} run run\r\n * @returns {Run} run without ommited attribute\r\n */\nvar omit = function omit(value, run) {\n  var attributes = Object.assign({}, run.attributes);\n  delete attributes[value];\n  return Object.assign({}, run, {\n    attributes: attributes\n  });\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Get run ascent\r\n *\r\n * @param {Run} run run\r\n * @returns {number} ascent\r\n */\nvar ascent$1 = function ascent(run) {\n  var _run$attributes, _run$attributes$attac, _run$attributes2, _run$attributes2$font;\n  var attachmentHeight = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$attac = _run$attributes.attachment) === null || _run$attributes$attac === void 0 ? void 0 : _run$attributes$attac.height) || 0;\n  var fontAscent = ((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : (_run$attributes2$font = _run$attributes2.font) === null || _run$attributes2$font === void 0 ? void 0 : _run$attributes2$font.ascent) || 0;\n  return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Get run descent\r\n *\r\n * @param {Run} run run\r\n * @returns {number} descent\r\n */\nvar descent = function descent(run) {\n  var _run$attributes, _run$attributes$font;\n  var fontDescent = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.descent) || 0;\n  return scale(run) * fontDescent;\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Get run lineGap\r\n *\r\n * @param {Object} run run\r\n * @returns {number} lineGap\r\n */\nvar lineGap = function lineGap(run) {\n  var _run$attributes, _run$attributes$font;\n  return (((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.lineGap) || 0) * scale(run);\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Get run height\r\n *\r\n * @param {Run} run run\r\n * @returns {number} height\r\n */\nvar height$1 = function height(run) {\n  var _run$attributes;\n  var lineHeight = (_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.lineHeight;\n  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Returns attributed string height\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} height\r\n */\nvar height = function height(attributedString) {\n  var reducer = function reducer(acc, run) {\n    return Math.max(acc, height$1(run));\n  };\n  return attributedString.runs.reduce(reducer, 0);\n};\n\n/**\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\n\n/**\r\n * Checks if two rects intersect each other\r\n *\r\n * @param {Rect} a rect A\r\n * @param {Rect} b rect B\r\n * @returns {boolean} whether rects intersect\r\n */\nvar intersects = function intersects(a, b) {\n  var x = Math.max(a.x, b.x);\n  var num1 = Math.min(a.x + a.width, b.x + b.width);\n  var y = Math.max(a.y, b.y);\n  var num2 = Math.min(a.y + a.height, b.y + b.height);\n  return num1 >= x && num2 >= y;\n};\nvar _excluded = [\"excludeRects\"];\nvar getLineFragment = function getLineFragment(lineRect, excludeRect) {\n  if (!intersects(excludeRect, lineRect)) return [lineRect];\n  var eStart = excludeRect.x;\n  var eEnd = excludeRect.x + excludeRect.width;\n  var lStart = lineRect.x;\n  var lEnd = lineRect.x + lineRect.width;\n  var a = Object.assign({}, lineRect, {\n    width: eStart - lStart\n  });\n  var b = Object.assign({}, lineRect, {\n    x: eEnd,\n    width: lEnd - eEnd\n  });\n  return [a, b].filter(function (r) {\n    return r.width > 0;\n  });\n};\nvar getLineFragments = function getLineFragments(rect, excludeRects) {\n  var fragments = [rect];\n  var _loop = function _loop() {\n    var excludeRect = excludeRects[i];\n    fragments = fragments.reduce(function (acc, fragment) {\n      var pieces = getLineFragment(fragment, excludeRect);\n      return acc.concat(pieces);\n    }, []);\n  };\n  for (var i = 0; i < excludeRects.length; i += 1) {\n    _loop();\n  }\n  return fragments;\n};\nvar generateLineRects = function generateLineRects(container, height) {\n  var excludeRects = container.excludeRects,\n    rect = _objectWithoutPropertiesLoose(container, _excluded);\n  if (!excludeRects) return [rect];\n  var lineRects = [];\n  var maxY = Math.max.apply(Math, excludeRects.map(function (r) {\n    return r.y + r.height;\n  }));\n  var currentRect = rect;\n  while (currentRect.y < maxY) {\n    var _partition = partition(currentRect, height),\n      lineRect = _partition[0],\n      rest = _partition[1];\n    var lineRectFragments = getLineFragments(lineRect, excludeRects);\n    currentRect = rest;\n    lineRects.push.apply(lineRects, lineRectFragments);\n  }\n  return [].concat(lineRects, [currentRect]);\n};\nvar ATTACHMENT_CODE$1 = \"\\uFFFC\"; // 65532\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\n\n/**\r\n * Remove attachment attribute if no char present\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {AttributedString} attributed string\r\n */\nvar purgeAttachments = function purgeAttachments(attributedString) {\n  var shouldPurge = !attributedString.string.includes(ATTACHMENT_CODE$1);\n  if (!shouldPurge) return attributedString;\n  var runs = attributedString.runs.map(function (run) {\n    return omit('attachment', run);\n  });\n  return Object.assign({}, attributedString, {\n    runs: runs\n  });\n};\n\n/**\r\n * Layout paragraphs inside rectangle\r\n *\r\n * @param {Object} rects rect\r\n * @param {Object[]} lines attributed strings\r\n * @param {number} indent\r\n * @returns {Object} layout blocks\r\n */\nvar layoutLines = function layoutLines(rects, lines, indent) {\n  var rect = rects.shift();\n  var currentY = rect.y;\n  return lines.map(function (line, i) {\n    var _line$runs, _line$runs$;\n    var lineIndent = i === 0 ? indent : 0;\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    var height$1 = Math.max(height(line), style.lineHeight);\n    if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n      rect = rects.shift();\n      currentY = rect.y;\n    }\n    var newLine = Object.assign({}, line);\n    delete newLine.syllables;\n    newLine.box = {\n      x: rect.x + lineIndent,\n      y: currentY,\n      width: rect.width - lineIndent,\n      height: height$1\n    };\n    currentY += height$1;\n    return purgeAttachments(newLine);\n  });\n};\n\n/**\r\n * Performs line breaking and layout\r\n *\r\n * @param {Object} engines engines\r\n * @param {Object} options layout options\r\n */\nvar layoutParagraph = function layoutParagraph(engines, options) {\n  /**\r\n   * @param {Rect} container rect\r\n   * @param {Object} paragraph attributed string\r\n   * @returns {Object} layout block\r\n   */\n  return function (container, paragraph) {\n    var _paragraph$runs, _paragraph$runs$, _paragraph$runs$$attr;\n    var height$1 = height(paragraph);\n    var indent = ((_paragraph$runs = paragraph.runs) === null || _paragraph$runs === void 0 ? void 0 : (_paragraph$runs$ = _paragraph$runs[0]) === null || _paragraph$runs$ === void 0 ? void 0 : (_paragraph$runs$$attr = _paragraph$runs$.attributes) === null || _paragraph$runs$$attr === void 0 ? void 0 : _paragraph$runs$$attr.indent) || 0;\n    var rects = generateLineRects(container, height$1);\n    var availableWidths = rects.map(function (r) {\n      return r.width;\n    });\n    availableWidths[0] -= indent;\n    var lines = engines.linebreaker(options)(paragraph, availableWidths);\n    return layoutLines(rects, lines, indent);\n  };\n};\n\n/**\r\n * Slice block at given height\r\n *\r\n * @param {number} height height\r\n * @param {Object} block paragraph block\r\n * @returns {number[]} sliced paragraph block\r\n */\nvar sliceAtHeight = function sliceAtHeight(height, block) {\n  var newBlock = [];\n  var counter = 0;\n  for (var i = 0; i < block.length; i += 1) {\n    var line = block[i];\n    counter += line.box.height;\n    if (counter < height) {\n      newBlock.push(line);\n    } else {\n      break;\n    }\n  }\n  return newBlock;\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\n\n/**\r\n * Layout paragraphs inside container until it does not\r\n * fit anymore, performing line wrapping in the process.\r\n *\r\n * @param {Object} engines engines\r\n * @param {Object} options layout options\r\n * @param {Rect} container container rect\r\n */\nvar typesetter = function typesetter(engines, options, container) {\n  /**\r\n   * @param {AttributedString} attributedStrings attributed strings (paragraphs)\r\n   * @returns {Object[]} paragraph blocks\r\n   */\n  return function (attributedStrings) {\n    var blocks = [];\n    var paragraphs = [].concat(attributedStrings);\n    var layoutBlock = layoutParagraph(engines, options);\n    var maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\n    var truncateEllipsis = container.truncateMode === 'ellipsis';\n    var linesCount = maxLines;\n    var paragraphRect = copy(container);\n    var nextParagraph = paragraphs.shift();\n    while (linesCount > 0 && nextParagraph) {\n      var block = layoutBlock(paragraphRect, nextParagraph);\n      var slicedBlock = block.slice(0, linesCount);\n      var linesHeight = height$2(slicedBlock);\n      var shouldTruncate = truncateEllipsis && block.length !== slicedBlock.length;\n      linesCount -= slicedBlock.length;\n      if (paragraphRect.height >= linesHeight) {\n        blocks.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n        paragraphRect = crop(linesHeight, paragraphRect);\n        nextParagraph = paragraphs.shift();\n      } else {\n        blocks.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n        break;\n      }\n    }\n    return blocks;\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Get attributed string start value\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} start\r\n */\nvar start = function start(attributedString) {\n  var runs = attributedString.runs;\n  return runs.length === 0 ? 0 : runs[0].start;\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Get attributed string end value\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} end\r\n */\nvar end = function end(attributedString) {\n  var runs = attributedString.runs;\n  return runs.length === 0 ? 0 : last(runs).end;\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Get attributed string length\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} end\r\n */\nvar length$1 = function length(attributedString) {\n  return end(attributedString) - start(attributedString);\n};\nvar bidi$2 = bidiFactory();\nvar getBidiLevels$1 = function getBidiLevels(runs) {\n  return runs.reduce(function (acc, run) {\n    var length = run.end - run.start;\n    var levels = repeat(run.attributes.bidiLevel, length);\n    return acc.concat(levels);\n  }, []);\n};\nvar getReorderedIndices = function getReorderedIndices(string, segments) {\n  // Fill an array with indices\n  var indices = [];\n  for (var i = 0; i < string.length; i += 1) {\n    indices[i] = i;\n  }\n  // Reverse each segment in order\n  segments.forEach(function (_ref) {\n    var start = _ref[0],\n      end = _ref[1];\n    var slice = indices.slice(start, end + 1);\n    for (var _i = slice.length - 1; _i >= 0; _i -= 1) {\n      indices[end - _i] = slice[_i];\n    }\n  });\n  return indices;\n};\nvar getItemAtIndex = function getItemAtIndex(runs, objectName, index) {\n  for (var i = 0; i < runs.length; i += 1) {\n    var run = runs[i];\n    var updatedIndex = run.glyphIndices[index - run.start];\n    if (index >= run.start && index < run.end) {\n      return run[objectName][updatedIndex];\n    }\n  }\n  throw new Error(\"index \" + index + \" out of range\");\n};\nvar reorderLine = function reorderLine(attributedString) {\n  var _attributedString$run;\n  var levels = getBidiLevels$1(attributedString.runs);\n  var direction = (_attributedString$run = attributedString.runs[0]) === null || _attributedString$run === void 0 ? void 0 : _attributedString$run.attributes.direction;\n  var level = direction === 'rtl' ? 1 : 0;\n  var end = length$1(attributedString) - 1;\n  var paragraphs = [{\n    start: 0,\n    end: end,\n    level: level\n  }];\n  var embeddingLevels = {\n    paragraphs: paragraphs,\n    levels: levels\n  };\n  var segments = bidi$2.getReorderSegments(attributedString.string, embeddingLevels);\n\n  // No need for bidi reordering\n  if (segments.length === 0) return attributedString;\n  var indices = getReorderedIndices(attributedString.string, segments);\n  var updatedString = bidi$2.getReorderedString(attributedString.string, embeddingLevels);\n  var updatedRuns = attributedString.runs.map(function (run) {\n    var selectedIndices = indices.slice(run.start, run.end);\n    var updatedGlyphs = [];\n    var updatedPositions = [];\n    var addedGlyphs = new Set();\n    for (var i = 0; i < selectedIndices.length; i += 1) {\n      var index = selectedIndices[i];\n      var glyph = getItemAtIndex(attributedString.runs, 'glyphs', index);\n      if (addedGlyphs.has(glyph.id)) continue;\n      updatedGlyphs.push(glyph);\n      updatedPositions.push(getItemAtIndex(attributedString.runs, 'positions', index));\n      if (glyph.isLigature) {\n        addedGlyphs.add(glyph.id);\n      }\n    }\n    return _extends({}, run, {\n      glyphs: updatedGlyphs,\n      positions: updatedPositions\n    });\n  });\n  return _extends({}, attributedString, {\n    runs: updatedRuns,\n    string: updatedString\n  });\n};\nvar reorderParagraph = function reorderParagraph(lines) {\n  return lines.map(reorderLine);\n};\n\n/**\r\n * Perform bidi reordering\r\n */\nvar bidiReordering = function bidiReordering() {\n  /**\r\n   * @param {Object[]} paragraphs line blocks\r\n   * @returns {Object[]} paragraphs\r\n   */\n  return function (paragraphs) {\n    return paragraphs.map(reorderParagraph);\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n */\n\nvar DUMMY_CODEPOINT = 123;\n\n/**\r\n * Resolve string indices based on glyphs code points\r\n *\r\n * @param {Glyph[]} glyphs\r\n * @returns {number[]} glyph indices\r\n */\nvar resolve = function resolve(glyphs) {\n  if (glyphs === void 0) {\n    glyphs = [];\n  }\n  return glyphs.reduce(function (acc, glyph) {\n    var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];\n    if (acc.length === 0) return codePoints.map(function () {\n      return 0;\n    });\n    var last = acc[acc.length - 1];\n    var next = codePoints.map(function () {\n      return last + 1;\n    });\n    return [].concat(acc, next);\n  }, []);\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Position} Position\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * @param {Run} run\r\n * @returns {number}\r\n */\nvar getCharacterSpacing = function getCharacterSpacing(run) {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.characterSpacing) || 0;\n};\n\n/**\r\n * Scale run positions\r\n *\r\n * @param {Run} run\r\n * @param {Position[]} positions\r\n * @returns {Position[]} scaled positions\r\n */\nvar scalePositions = function scalePositions(run, positions) {\n  var runScale = scale(run);\n  var characterSpacing = getCharacterSpacing(run);\n  return positions.map(function (position, i) {\n    var isLast = i === positions.length;\n    var xSpacing = isLast ? 0 : characterSpacing;\n    return Object.assign({}, position, {\n      xAdvance: position.xAdvance * runScale + xSpacing,\n      yAdvance: position.yAdvance * runScale,\n      xOffset: position.xOffset * runScale,\n      yOffset: position.yOffset * runScale\n    });\n  });\n};\n\n/**\r\n * Create glyph run\r\n *\r\n * @param {string} string string\r\n */\nvar layoutRun = function layoutRun(string) {\n  /**\r\n   * @param {Run} run run\r\n   * @returns {Run} glyph run\r\n   */\n  return function (run) {\n    var start = run.start,\n      end = run.end,\n      _run$attributes2 = run.attributes,\n      attributes = _run$attributes2 === void 0 ? {} : _run$attributes2;\n    var font = attributes.font;\n    if (!font) return _extends({}, run, {\n      glyphs: [],\n      glyphIndices: [],\n      positions: []\n    });\n    var runString = string.slice(start, end);\n\n    // passing LTR To force fontkit to not reverse the string\n    var glyphRun = font.layout(runString, undefined, undefined, undefined, 'ltr');\n    var positions = scalePositions(run, glyphRun.positions);\n    var glyphIndices = resolve(glyphRun.glyphs);\n    return _extends({}, run, {\n      positions: positions,\n      glyphIndices: glyphIndices,\n      glyphs: glyphRun.glyphs\n    });\n  };\n};\n\n/**\r\n * Generate glyphs for single attributed string\r\n */\nvar generateGlyphs = function generateGlyphs() {\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string with glyphs\r\n   */\n  return function (attributedString) {\n    var runs = attributedString.runs.map(layoutRun(attributedString.string));\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Resolves yOffset for run\r\n *\r\n * @param {Run} run run\r\n * @returns {Run} run\r\n */\nvar resolveRunYOffset = function resolveRunYOffset(run) {\n  var _run$attributes, _run$attributes$font, _run$attributes2;\n  if (!run.positions) return run;\n  var unitsPerEm = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.unitsPerEm) || 0;\n  var yOffset = (((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : _run$attributes2.yOffset) || 0) * unitsPerEm;\n  var positions = run.positions.map(function (p) {\n    return Object.assign({}, p, {\n      yOffset: yOffset\n    });\n  });\n  return Object.assign({}, run, {\n    positions: positions\n  });\n};\n\n/**\r\n * Resolves yOffset for multiple paragraphs\r\n */\nvar resolveYOffset = function resolveYOffset() {\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\n  return function (attributedString) {\n    var runs = attributedString.runs.map(resolveRunYOffset);\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Sort runs in ascending order\r\n *\r\n * @param {Run[]} runs\r\n * @returns {Run[]} sorted runs\r\n */\nvar sort = function sort(runs) {\n  return runs.sort(function (a, b) {\n    return a.start - b.start || a.end - b.end;\n  });\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Is run empty (start === end)\r\n *\r\n * @param {Run} run run\r\n * @returns {boolean} is run empty\r\n */\nvar isEmpty = function isEmpty(run) {\n  return run.start === run.end;\n};\n\n/**\r\n * @typedef {import('../types.js').Point} Point\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Sort points in ascending order\r\n * @param {Point} a first point\r\n * @param {Point} b second point\r\n * @returns {number} sort order\r\n */\nvar sortPoints = function sortPoints(a, b) {\n  return a[1] - b[1] || a[3] - b[3];\n};\n\n/**\r\n * @param {Run[]} runs\r\n * @returns {Point[]} points\r\n */\nvar generatePoints = function generatePoints(runs) {\n  var result = runs.reduce(function (acc, run, i) {\n    return acc.concat([['start', run.start, run.attributes, i], ['end', run.end, run.attributes, i]]);\n  }, []);\n  return result.sort(sortPoints);\n};\n\n/**\r\n * @param {Run[]} runs\r\n * @returns {Run} merged runs\r\n */\nvar mergeRuns = function mergeRuns(runs) {\n  return runs.reduce(function (acc, run) {\n    var attributes = Object.assign({}, acc.attributes, run.attributes);\n    return Object.assign({}, run, {\n      attributes: attributes\n    });\n  }, {});\n};\n\n/**\r\n * @param {Run[]} runs\r\n * @returns {Run[][]} grouped runs\r\n */\nvar groupEmptyRuns = function groupEmptyRuns(runs) {\n  var groups = runs.reduce(function (acc, run) {\n    if (!acc[run.start]) acc[run.start] = [];\n    acc[run.start].push(run);\n    return acc;\n  }, []);\n  return Object.values(groups);\n};\n\n/**\r\n * @param {Run[]} runs\r\n * @returns {Run[]} flattened runs\r\n */\nvar flattenEmptyRuns = function flattenEmptyRuns(runs) {\n  return groupEmptyRuns(runs).map(mergeRuns);\n};\n\n/**\r\n * @param {Run[]} runs\r\n * @returns {Run[]} flattened runs\r\n */\nvar flattenRegularRuns = function flattenRegularRuns(runs) {\n  var res = [];\n  var points = generatePoints(runs);\n  var start = -1;\n  var attrs = {};\n  var stack = [];\n  for (var i = 0; i < points.length; i += 1) {\n    var _points$i = points[i],\n      type = _points$i[0],\n      offset = _points$i[1],\n      attributes = _points$i[2];\n    if (start !== -1 && start < offset) {\n      res.push({\n        start: start,\n        end: offset,\n        attributes: attrs\n      });\n    }\n    if (type === 'start') {\n      stack.push(attributes);\n      attrs = Object.assign({}, attrs, attributes);\n    } else {\n      attrs = {};\n      for (var j = 0; j < stack.length; j += 1) {\n        if (stack[j] === attributes) {\n          // eslint-disable-next-line no-plusplus\n          stack.splice(j--, 1);\n        } else {\n          attrs = Object.assign({}, attrs, stack[j]);\n        }\n      }\n    }\n    start = offset;\n  }\n  return res;\n};\n\n/**\r\n * Flatten many runs\r\n *\r\n * @param {Run[]} runs\r\n * @returns {Run[]} flattened runs\r\n */\nvar flatten = function flatten(runs) {\n  if (runs === void 0) {\n    runs = [];\n  }\n  var emptyRuns = flattenEmptyRuns(runs.filter(function (run) {\n    return isEmpty(run);\n  }));\n  var regularRuns = flattenRegularRuns(runs.filter(function (run) {\n    return !isEmpty(run);\n  }));\n  return sort(emptyRuns.concat(regularRuns));\n};\n\n/**\r\n * Returns empty attributed string\r\n *\r\n * @returns {Object} empty attributed string\r\n */\nvar empty = function empty() {\n  return {\n    string: '',\n    runs: []\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n *\r\n * @param {AttributedString} attributedString\r\n * @returns {AttributedString} attributed string without font\r\n */\nvar omitFont = function omitFont(attributedString) {\n  var runs = attributedString.runs.map(function (run) {\n    return omit('font', run);\n  });\n  return Object.assign({}, attributedString, {\n    runs: runs\n  });\n};\n\n/**\r\n * Performs font substitution and script itemization on attributed string\r\n *\r\n * @param {Object} engines engines\r\n * @param {Object} options layout options\r\n */\nvar preprocessRuns = function preprocessRuns(engines, options) {\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} processed attributed string\r\n   */\n  return function (attributedString) {\n    if (isNil(attributedString)) return empty();\n    var string = attributedString.string;\n    var fontSubstitution = engines.fontSubstitution,\n      scriptItemizer = engines.scriptItemizer,\n      bidi = engines.bidi;\n    var _omitFont = omitFont(attributedString),\n      omittedFontRuns = _omitFont.runs;\n    var _scriptItemizer = scriptItemizer(options)(attributedString),\n      itemizationRuns = _scriptItemizer.runs;\n    var _fontSubstitution = fontSubstitution(options)(attributedString),\n      substitutedRuns = _fontSubstitution.runs;\n    var _bidi = bidi(options)(attributedString),\n      bidiRuns = _bidi.runs;\n    var runs = bidiRuns.concat(substitutedRuns).concat(itemizationRuns).concat(omittedFontRuns);\n    return {\n      string: string,\n      runs: flatten(runs)\n    };\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Breaks attributed string into paragraphs\r\n */\nvar splitParagraphs = function splitParagraphs() {\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString[]} attributed string array\r\n   */\n  return function (attributedString) {\n    var res = [];\n    var start = 0;\n    var breakPoint = attributedString.string.indexOf('\\n') + 1;\n    while (breakPoint > 0) {\n      res.push(slice(start, breakPoint, attributedString));\n      start = breakPoint;\n      breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n    }\n    if (start === 0) {\n      res.push(attributedString);\n    } else if (start < attributedString.string.length) {\n      res.push(slice(start, length$1(attributedString), attributedString));\n    }\n    return res;\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').Position} Position\r\n */\n\n/**\r\n * Return positions advance width\r\n *\r\n * @param {Position[]} positions positions\r\n * @returns {number} advance width\r\n */\nvar advanceWidth$2 = function advanceWidth(positions) {\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Return run advance width\r\n *\r\n * @param {Run} run run\r\n * @returns {number} advance width\r\n */\nvar advanceWidth$1 = function advanceWidth(run) {\n  return advanceWidth$2(run.positions || []);\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Returns attributed string advancewidth\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} advance width\r\n */\nvar advanceWidth = function advanceWidth(attributedString) {\n  var reducer = function reducer(acc, run) {\n    return acc + advanceWidth$1(run);\n  };\n  return attributedString.runs.reduce(reducer, 0);\n};\n\n/**\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n */\n\nvar WHITE_SPACES_CODE = 32;\n\n/**\r\n * Check if glyph is white space\r\n *\r\n * @param {Glyph} [glyph] glyph\r\n * @returns {boolean} whether glyph is white space\r\n * */\nvar isWhiteSpace = function isWhiteSpace(glyph) {\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  return codePoints.includes(WHITE_SPACES_CODE);\n};\n\n/**\r\n * @typedef {import('../types.js').Position} Position\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Get white space leading positions\r\n *\r\n * @param {Run} run run\r\n * @returns {Position[]} white space leading positions\r\n */\nvar leadingPositions = function leadingPositions(run) {\n  var glyphs = run.glyphs || [];\n  var positions = run.positions || [];\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\n    return !isWhiteSpace(g);\n  });\n  return positions.slice(0, leadingWhitespaces);\n};\n\n/**\r\n * Get run leading white space offset\r\n *\r\n * @param {Run} run run\r\n * @returns {number} leading white space offset\r\n */\nvar leadingOffset$1 = function leadingOffset(run) {\n  var positions = leadingPositions(run);\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Get attributed string leading white space offset\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} leading white space offset\r\n */\nvar leadingOffset = function leadingOffset(attributedString) {\n  var runs = attributedString.runs || [];\n  return leadingOffset$1(runs[0]);\n};\n\n/**\r\n * @typedef {import('../types.js').Position} Position\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * @template T\r\n * @param {T[]} array\r\n * @returns {T[]} reversed array\r\n */\nvar reverse = function reverse(array) {\n  return [].concat(array).reverse();\n};\n\n/**\r\n * Get white space trailing positions\r\n *\r\n * @param {Run} run run\r\n * @returns {Position[]} white space trailing positions\r\n */\nvar trailingPositions = function trailingPositions(run) {\n  var glyphs = reverse(run.glyphs || []);\n  var positions = reverse(run.positions || []);\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\n    return !isWhiteSpace(g);\n  });\n  return positions.slice(0, leadingWhitespaces);\n};\n\n/**\r\n * Get run trailing white space offset\r\n *\r\n * @param {Run} run run\r\n * @returns {number} trailing white space offset\r\n */\nvar trailingOffset$1 = function trailingOffset(run) {\n  var positions = trailingPositions(run);\n  return positions.reduce(function (acc, pos) {\n    return acc + (pos.xAdvance || 0);\n  }, 0);\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Get attributed string trailing white space offset\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} trailing white space offset\r\n */\nvar trailingOffset = function trailingOffset(attributedString) {\n  var runs = attributedString.runs || [];\n  return trailingOffset$1(last(runs));\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Drop last char of run\r\n *\r\n * @param {Run} run run\r\n * @returns {Run} run without last char\r\n */\nvar dropLast$1 = function dropLast(run) {\n  return slice$1(0, run.end - run.start - 1, run);\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Drop last glyph\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {AttributedString} attributed string with new glyph\r\n */\nvar dropLast = function dropLast(attributedString) {\n  var string = dropLast$2(attributedString.string);\n  var runs = adjust(-1, dropLast$1, attributedString.runs);\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\nvar ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n\n/**\r\n * Remove new line char at the end of line if present\r\n *\r\n * @param {Object}  line\r\n * @returns {Object} line\r\n */\nvar removeNewLine = function removeNewLine(line) {\n  return last(line.string) === '\\n' ? dropLast(line) : line;\n};\nvar getOverflowLeft = function getOverflowLeft(line) {\n  return leadingOffset(line) + (line.overflowLeft || 0);\n};\nvar getOverflowRight = function getOverflowRight(line) {\n  return trailingOffset(line) + (line.overflowRight || 0);\n};\n\n/**\r\n * Ignore whitespace at the start and end of a line for alignment\r\n *\r\n * @param {Object}  line\r\n * @returns {Object} line\r\n */\nvar adjustOverflow = function adjustOverflow(line) {\n  var overflowLeft = getOverflowLeft(line);\n  var overflowRight = getOverflowRight(line);\n  var x = line.box.x - overflowLeft;\n  var width = line.box.width + overflowLeft + overflowRight;\n  var box = Object.assign({}, line.box, {\n    x: x,\n    width: width\n  });\n  return Object.assign({}, line, {\n    box: box,\n    overflowLeft: overflowLeft,\n    overflowRight: overflowRight\n  });\n};\n\n/**\r\n * Performs line justification by calling appropiate engine\r\n *\r\n * @param {Object} engines engines\r\n * @param {Object} options layout options\r\n * @param {string} align text align\r\n */\nvar justifyLine$1 = function justifyLine(engines, options, align) {\n  /**\r\n   * @param {Object} line lint\r\n   * @returns {Object} line\r\n   */\n  return function (line) {\n    var lineWidth = advanceWidth(line);\n    var alignFactor = ALIGNMENT_FACTORS[align] || 0;\n    var remainingWidth = Math.max(0, line.box.width - lineWidth);\n    var shouldJustify = align === 'justify' || lineWidth > line.box.width;\n    var x = line.box.x + remainingWidth * alignFactor;\n    var box = Object.assign({}, line.box, {\n      x: x\n    });\n    var newLine = Object.assign({}, line, {\n      box: box\n    });\n    return shouldJustify ? engines.justification(options)(newLine) : newLine;\n  };\n};\nvar finalizeLine = function finalizeLine(line) {\n  var lineAscent = 0;\n  var lineDescent = 0;\n  var lineHeight = 0;\n  var lineXAdvance = 0;\n  var runs = line.runs.map(function (run) {\n    var height = height$1(run);\n    var ascent = ascent$1(run);\n    var descent$1 = descent(run);\n    var xAdvance = advanceWidth$1(run);\n    lineHeight = Math.max(lineHeight, height);\n    lineAscent = Math.max(lineAscent, ascent);\n    lineDescent = Math.max(lineDescent, descent$1);\n    lineXAdvance += xAdvance;\n    return Object.assign({}, run, {\n      height: height,\n      ascent: ascent,\n      descent: descent$1,\n      xAdvance: xAdvance\n    });\n  });\n  return Object.assign({}, line, {\n    runs: runs,\n    height: lineHeight,\n    ascent: lineAscent,\n    descent: lineDescent,\n    xAdvance: lineXAdvance\n  });\n};\n\n/**\r\n * Finalize line by performing line justification\r\n * and text decoration (using appropiate engines)\r\n *\r\n * @param {Object} engines engines\r\n * @param {Object} options layout options\r\n */\nvar finalizeBlock = function finalizeBlock(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n  /**\r\n   * @param {Object} line lint\r\n   * @param {number} i line index\r\n   * @param {Object[]} lines total lines\r\n   * @returns {Object} line\r\n   */\n  return function (line, i, lines) {\n    var _line$runs, _line$runs$;\n    var isLastFragment = i === lines.length - 1;\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    var align = isLastFragment ? style.alignLastLine : style.align;\n    return compose(finalizeLine, engines.textDecoration(options), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n\n/**\r\n * Finalize line block by performing line justification\r\n * and text decoration (using appropiate engines)\r\n *\r\n * @param {Object} engines engines\r\n * @param {Object} options layout options\r\n */\nvar finalizeFragments = function finalizeFragments(engines, options) {\n  /**\r\n   * @param {Object[]} blocks line blocks\r\n   * @returns {Object[]} blocks\r\n   */\n  return function (blocks) {\n    var blockFinalizer = finalizeBlock(engines, options);\n    return blocks.map(function (block) {\n      return block.map(blockFinalizer);\n    });\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\nvar ATTACHMENT_CODE = 0xfffc; // 65532\n\nvar isReplaceGlyph = function isReplaceGlyph(glyph) {\n  return glyph.codePoints.includes(ATTACHMENT_CODE);\n};\n\n/**\r\n * Resolve attachments of run\r\n *\r\n * @param {Object}  run\r\n * @returns {Object} run\r\n */\nvar resolveRunAttachments = function resolveRunAttachments(run) {\n  var _run$attributes;\n  if (!run.positions) return run;\n  var glyphs = run.glyphs || [];\n  var attachment = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.attachment) || {};\n  var positions = run.positions.map(function (position, i) {\n    var glyph = glyphs[i];\n    if (attachment && attachment.width && isReplaceGlyph(glyph)) {\n      return Object.assign({}, position, {\n        xAdvance: attachment.width\n      });\n    }\n    return Object.assign({}, position);\n  });\n  return Object.assign({}, run, {\n    positions: positions\n  });\n};\n\n/**\r\n * Resolve attachments for multiple paragraphs\r\n */\nvar resolveAttachments = function resolveAttachments() {\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\n  return function (attributedString) {\n    var runs = attributedString.runs.map(resolveRunAttachments);\n    return Object.assign({}, attributedString, {\n      runs: runs\n    });\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Attributes} Attributes\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * @param {Attributes} a attributes\r\n * @returns {Attributes} attributes with defaults\r\n */\nvar applyAttributes = function applyAttributes(a) {\n  return {\n    align: a.align || (a.direction === 'rtl' ? 'right' : 'left'),\n    alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n    attachment: a.attachment || null,\n    backgroundColor: a.backgroundColor || null,\n    bullet: a.bullet || null,\n    characterSpacing: a.characterSpacing || 0,\n    color: a.color || 'black',\n    direction: a.direction || 'ltr',\n    features: a.features || [],\n    fill: a.fill !== false,\n    font: a.font || null,\n    fontSize: a.fontSize || 12,\n    hangingPunctuation: a.hangingPunctuation || false,\n    hyphenationFactor: a.hyphenationFactor || 0,\n    indent: a.indent || 0,\n    justificationFactor: a.justificationFactor || 1,\n    lineHeight: a.lineHeight || null,\n    lineSpacing: a.lineSpacing || 0,\n    link: a.link || null,\n    marginLeft: a.marginLeft || a.margin || 0,\n    marginRight: a.marginRight || a.margin || 0,\n    opacity: a.opacity,\n    paddingTop: a.paddingTop || a.padding || 0,\n    paragraphSpacing: a.paragraphSpacing || 0,\n    script: a.script || null,\n    shrinkFactor: a.shrinkFactor || 0,\n    strike: a.strike || false,\n    strikeColor: a.strikeColor || a.color || 'black',\n    strikeStyle: a.strikeStyle || 'solid',\n    stroke: a.stroke || false,\n    underline: a.underline || false,\n    underlineColor: a.underlineColor || a.color || 'black',\n    underlineStyle: a.underlineStyle || 'solid',\n    verticalAlign: a.verticalAlign || null,\n    wordSpacing: a.wordSpacing || 0,\n    yOffset: a.yOffset || 0\n  };\n};\n\n/**\r\n * Apply default style to run\r\n *\r\n * @param {Run} run run\r\n * @returns {Run} run with styles\r\n */\nvar applyRunStyles = function applyRunStyles(run) {\n  var attributes = applyAttributes(run.attributes);\n  return Object.assign({}, run, {\n    attributes: attributes\n  });\n};\n\n/**\r\n * Apply default attributes for an attributed string\r\n */\nvar applyDefaultStyles = function applyDefaultStyles() {\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\n  return function (attributedString) {\n    var string = attributedString.string || '';\n    var runs = (attributedString.runs || []).map(applyRunStyles);\n    return {\n      string: string,\n      runs: runs\n    };\n  };\n};\n\n/* eslint-disable no-restricted-syntax */\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\r\n */\nvar verticalAlignment = function verticalAlignment() {\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\n  return function (attributedString) {\n    attributedString.runs.forEach(function (run) {\n      var attributes = run.attributes;\n      var verticalAlign = attributes.verticalAlign;\n      if (verticalAlign === 'sub') {\n        attributes.yOffset = -0.2;\n      } else if (verticalAlign === 'super') {\n        attributes.yOffset = 0.4;\n      }\n    });\n    return attributedString;\n  };\n};\nvar bidi$1 = bidiFactory();\nvar getBidiLevels = function getBidiLevels(runs) {\n  return runs.reduce(function (acc, run) {\n    var length = run.end - run.start;\n    var levels = repeat(run.attributes.bidiLevel, length);\n    return acc.concat(levels);\n  }, []);\n};\n\n/**\r\n * Perform bidi mirroring\r\n */\nvar mirrorString = function mirrorString() {\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\n  return function (attributedString) {\n    var levels = getBidiLevels(attributedString.runs);\n    var updatedString = '';\n    attributedString.string.split('').forEach(function (char, index) {\n      var isRTL = levels[index] % 2 === 1;\n      var mirroredChar = isRTL ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index)) : null;\n      updatedString += mirroredChar || char;\n    });\n    return _extends({}, attributedString, {\n      string: updatedString,\n      levels: levels\n    });\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\n\n/**\r\n * A LayoutEngine is the main object that performs text layout.\r\n * It accepts an AttributedString and a Container object\r\n * to layout text into, and uses several helper objects to perform\r\n * various layout tasks. These objects can be overridden to customize\r\n * layout behavior.\r\n *\r\n * @param {Object} engines engines\r\n */\nvar layoutEngine = function layoutEngine(engines) {\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @param {Rect} container container rect\r\n   * @param {Object} options layout options\r\n   * @returns {Object[]} paragraph blocks\r\n   */\n  return function (attributedString, container, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines, options), generateGlyphs(), mirrorString(), preprocessRuns(engines, options));\n    var processParagraphs = function processParagraphs(paragraphs) {\n      return paragraphs.map(processParagraph);\n    };\n    return compose(finalizeFragments(engines, options), bidiReordering(), typesetter(engines, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);\n  };\n};\nvar bidi = bidiFactory();\n\n/**\r\n * @param  {Object}  layout options\r\n * @param  {Object}  attributed string\r\n * @return {Object} attributed string\r\n */\nvar bidiEngine = function bidiEngine() {\n  return function (attributedString) {\n    var _attributedString$run;\n    var string = attributedString.string;\n    var direction = (_attributedString$run = attributedString.runs[0]) === null || _attributedString$run === void 0 ? void 0 : _attributedString$run.attributes.direction;\n    var _bidi$getEmbeddingLev = bidi.getEmbeddingLevels(string, direction),\n      levels = _bidi$getEmbeddingLev.levels;\n    var lastLevel = null;\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n    for (var i = 0; i < levels.length; i += 1) {\n      var level = levels[i];\n      if (level !== lastLevel) {\n        if (lastLevel !== null) {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              bidiLevel: lastLevel\n            }\n          });\n        }\n        lastIndex = index;\n        lastLevel = level;\n      }\n      index += 1;\n    }\n    if (lastIndex < string.length) {\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          bidiLevel: lastLevel\n        }\n      });\n    }\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\n/* eslint-disable no-plusplus */\nvar INFINITY = 10000;\n\n/**\r\n * @param {Object[]} subnodes\r\n * @param {number[]} widths\r\n * @param {number} lineNumber\r\n * @returns {number}\r\n */\nvar getNextBreakpoint = function getNextBreakpoint(subnodes, widths, lineNumber) {\n  var position = null;\n  var minimumBadness = Infinity;\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n  var calculateRatio = function calculateRatio(node) {\n    if (sum.width < lineLength) {\n      return sum.stretch - node.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n    if (sum.width > lineLength) {\n      return sum.shrink - node.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n    return 0;\n  };\n  for (var i = 0; i < subnodes.length; i += 1) {\n    var node = subnodes[i];\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n    if (sum.width - sum.shrink > lineLength) {\n      if (position === null) {\n        var j = i === 0 ? i + 1 : i;\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n          j++;\n        }\n        position = j - 1;\n      }\n      break;\n    }\n    if (node.type === 'penalty' || node.type === 'glue') {\n      var ratio = calculateRatio(node);\n      var penalty = node.type === 'penalty' ? node.penalty : 0;\n      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\n\n/**\r\n * @param {Object[]} nodes\r\n * @param {number[]} widths\r\n */\nvar applyBestFit = function applyBestFit(nodes, widths) {\n  var count = 0;\n  var lineNumber = 0;\n  var subnodes = nodes;\n  var breakpoints = [{\n    position: 0\n  }];\n  while (subnodes.length > 0) {\n    var breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n    if (breakpoint !== null) {\n      count += breakpoint;\n      breakpoints.push({\n        position: count\n      });\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n  return breakpoints;\n};\n\n/* eslint-disable no-param-reassign */\n/* eslint-disable max-classes-per-file */\nvar Node = /*#__PURE__*/function () {\n  function Node(data) {\n    this.prev = null;\n    this.next = null;\n    this.data = data;\n  }\n  var _proto = Node.prototype;\n  _proto.toString = function toString() {\n    return this.data.toString();\n  };\n  return Node;\n}();\nvar LinkedList = /*#__PURE__*/function () {\n  function LinkedList() {\n    this.head = null;\n    this.tail = null;\n    this.listSize = 0;\n    this.listLength = 0;\n  }\n  var _proto2 = LinkedList.prototype;\n  _proto2.isLinked = function isLinked(node) {\n    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());\n  };\n  _proto2.size = function size() {\n    return this.listSize;\n  };\n  _proto2.isEmpty = function isEmpty() {\n    return this.listSize === 0;\n  };\n  _proto2.first = function first() {\n    return this.head;\n  };\n  _proto2.last = function last() {\n    return this.last;\n  };\n  _proto2.toString = function toString() {\n    return this.toArray().toString();\n  };\n  _proto2.toArray = function toArray() {\n    var node = this.head;\n    var result = [];\n    while (node !== null) {\n      result.push(node);\n      node = node.next;\n    }\n    return result;\n  };\n  _proto2.forEach = function forEach(fun) {\n    var node = this.head;\n    while (node !== null) {\n      fun(node);\n      node = node.next;\n    }\n  };\n  _proto2.contains = function contains(n) {\n    var node = this.head;\n    if (!this.isLinked(n)) {\n      return false;\n    }\n    while (node !== null) {\n      if (node === n) {\n        return true;\n      }\n      node = node.next;\n    }\n    return false;\n  };\n  _proto2.at = function at(i) {\n    var node = this.head;\n    var index = 0;\n    if (i >= this.listLength || i < 0) {\n      return null;\n    }\n    while (node !== null) {\n      if (i === index) {\n        return node;\n      }\n      node = node.next;\n      index += 1;\n    }\n    return null;\n  };\n  _proto2.insertAfter = function insertAfter(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next === null) {\n      this.tail = newNode;\n    } else {\n      node.next.prev = newNode;\n    }\n    node.next = newNode;\n    this.listSize += 1;\n    return this;\n  };\n  _proto2.insertBefore = function insertBefore(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev === null) {\n      this.head = newNode;\n    } else {\n      node.prev.next = newNode;\n    }\n    node.prev = newNode;\n    this.listSize += 1;\n    return this;\n  };\n  _proto2.push = function push(node) {\n    if (this.head === null) {\n      this.unshift(node);\n    } else {\n      this.insertAfter(this.tail, node);\n    }\n    return this;\n  };\n  _proto2.unshift = function unshift(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      node.prev = null;\n      node.next = null;\n      this.listSize += 1;\n    } else {\n      this.insertBefore(this.head, node);\n    }\n    return this;\n  };\n  _proto2.remove = function remove(node) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n    if (node.prev === null) {\n      this.head = node.next;\n    } else {\n      node.prev.next = node.next;\n    }\n    if (node.next === null) {\n      this.tail = node.prev;\n    } else {\n      node.next.prev = node.prev;\n    }\n    this.listSize -= 1;\n    return this;\n  };\n  _proto2.pop = function pop() {\n    var node = this.tail;\n    this.tail.prev.next = null;\n    this.tail = this.tail.prev;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  };\n  _proto2.shift = function shift() {\n    var node = this.head;\n    this.head.next.prev = null;\n    this.head = this.head.next;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  };\n  return LinkedList;\n}();\nLinkedList.Node = Node;\n\n/* eslint-disable no-restricted-properties */\n\n/**\r\n * @param {Object[]} nodes\r\n * @param {number[]} lines\r\n * @param {Object} settings\r\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\r\n *\r\n * Licensed under the new BSD License.\r\n * Copyright 2009-2010, Bram Stein\r\n * All rights reserved.\r\n */\nvar linebreak = function linebreak(nodes, lines, settings) {\n  var options = {\n    demerits: {\n      line: settings && settings.demerits && settings.demerits.line || 10,\n      flagged: settings && settings.demerits && settings.demerits.flagged || 100,\n      fitness: settings && settings.demerits && settings.demerits.fitness || 3000\n    },\n    tolerance: settings && settings.tolerance || 3\n  };\n  var activeNodes = new LinkedList();\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLengths = lines;\n  var breaks = [];\n  var tmp = {\n    data: {\n      demerits: Infinity\n    }\n  };\n  function breakpoint(position, demerits, ratio, line, fitnessClass, totals, previous) {\n    return {\n      position: position,\n      demerits: demerits,\n      ratio: ratio,\n      line: line,\n      fitnessClass: fitnessClass,\n      totals: totals || {\n        width: 0,\n        stretch: 0,\n        shrink: 0\n      },\n      previous: previous\n    };\n  }\n  function computeCost(start, end, active, currentLine) {\n    var width = sum.width - active.totals.width;\n    var stretch = 0;\n    var shrink = 0;\n    // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n    var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n    if (nodes[end].type === 'penalty') {\n      width += nodes[end].width;\n    }\n    if (width < lineLength) {\n      // Calculate the stretch ratio\n      stretch = sum.stretch - active.totals.stretch;\n      if (stretch > 0) {\n        return (lineLength - width) / stretch;\n      }\n      return linebreak.infinity;\n    }\n    if (width > lineLength) {\n      // Calculate the shrink ratio\n      shrink = sum.shrink - active.totals.shrink;\n      if (shrink > 0) {\n        return (lineLength - width) / shrink;\n      }\n      return linebreak.infinity;\n    }\n\n    // perfect match\n    return 0;\n  }\n\n  // Add width, stretch and shrink values from the current\n  // break point up to the next box or forced penalty.\n  function computeSum(breakPointIndex) {\n    var result = {\n      width: sum.width,\n      stretch: sum.stretch,\n      shrink: sum.shrink\n    };\n    for (var i = breakPointIndex; i < nodes.length; i += 1) {\n      if (nodes[i].type === 'glue') {\n        result.width += nodes[i].width;\n        result.stretch += nodes[i].stretch;\n        result.shrink += nodes[i].shrink;\n      } else if (nodes[i].type === 'box' || nodes[i].type === 'penalty' && nodes[i].penalty === -linebreak.infinity && i > breakPointIndex) {\n        break;\n      }\n    }\n    return result;\n  }\n\n  // The main loop of the algorithm\n  // eslint-disable-next-line no-shadow\n  function mainLoop(node, index, nodes) {\n    var active = activeNodes.first();\n    var next = null;\n    var ratio = 0;\n    var demerits = 0;\n    /**\r\n     * @type {Object[]}\r\n     */\n    var candidates = [];\n    var badness;\n    var currentLine = 0;\n    var tmpSum;\n    var currentClass = 0;\n    var fitnessClass;\n    /**\r\n     * @type {Object}\r\n     */\n    var candidate;\n    var newNode;\n\n    // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n    while (active !== null) {\n      candidates = [{\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }];\n\n      // Iterate through the linked list of active nodes to find new potential active nodes\n      // and deactivate current active nodes.\n      while (active !== null) {\n        next = active.next;\n        currentLine = active.data.line + 1;\n        ratio = computeCost(active.data.position, index, active.data, currentLine);\n\n        // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        }\n\n        // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          badness = 100 * Math.pow(Math.abs(ratio), 3);\n\n          // Positive penalty\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2);\n            // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2);\n            // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * nodes[active.data.position].flagged;\n          }\n\n          // Calculate the fitness class for this candidate active node.\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          }\n\n          // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines\n          // differ too much.\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          }\n\n          // Add the total demerits of the active node to get the total demerits of this candidate node.\n          demerits += active.data.demerits;\n\n          // Only store the best candidate for each fitness class\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active: active,\n              demerits: demerits,\n              ratio: ratio\n            };\n          }\n        }\n        active = next;\n\n        // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n      tmpSum = computeSum(index);\n      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        candidate = candidates[fitnessClass];\n        if (candidate.demerits < Infinity) {\n          newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n          if (active !== null) {\n            activeNodes.insertBefore(active, newNode);\n          } else {\n            activeNodes.push(newNode);\n          }\n        }\n      }\n    }\n  }\n\n  // Add an active node for the start of the paragraph.\n  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, 0, undefined, null)));\n\n  // eslint-disable-next-line no-shadow\n  nodes.forEach(function (node, index, nodes) {\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      if (index > 0 && nodes[index - 1].type === 'box') {\n        mainLoop(node, index, nodes);\n      }\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    } else if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n  if (activeNodes.size() !== 0) {\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach(function (node) {\n      if (node.data.demerits < tmp.data.demerits) {\n        tmp = node;\n      }\n    });\n    while (tmp !== null) {\n      breaks.push({\n        position: tmp.data.position,\n        ratio: tmp.data.ratio\n      });\n      tmp = tmp.data.previous;\n    }\n    return breaks.reverse();\n  }\n  return [];\n};\nlinebreak.infinity = 10000;\nlinebreak.glue = function (width, value, stretch, shrink) {\n  return {\n    type: 'glue',\n    value: value,\n    width: width,\n    stretch: stretch,\n    shrink: shrink\n  };\n};\nlinebreak.box = function (width, value, hyphenated) {\n  if (hyphenated === void 0) {\n    hyphenated = false;\n  }\n  return {\n    type: 'box',\n    width: width,\n    value: value,\n    hyphenated: hyphenated\n  };\n};\nlinebreak.penalty = function (width, penalty, flagged) {\n  return {\n    type: 'penalty',\n    width: width,\n    penalty: penalty,\n    flagged: flagged\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Add scalar to run\r\n *\r\n * @param {number} n scalar\r\n * @param {Run} run run\r\n * @returns {Run} added run\r\n */\nvar add = function add(n, run) {\n  var start = run.start + n;\n  var end = run.end + n;\n  return Object.assign({}, run, {\n    start: start,\n    end: end\n  });\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Get run length\r\n *\r\n * @param {Run} run run\r\n * @returns {number} length\r\n */\nvar length = function length(run) {\n  return run.end - run.start;\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Concats two runs into one\r\n *\r\n * @param {Run} runA first run\r\n * @param {Run} runB second run\r\n * @returns {Run} concatenated run\r\n */\nvar concat = function concat(runA, runB) {\n  var end = runA.end + length(runB);\n  var glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n  var positions = (runA.positions || []).concat(runB.positions || []);\n  var attributes = Object.assign({}, runA.attributes, runB.attributes);\n  var runAIndices = runA.glyphIndices || [];\n  var runALastIndex = last(runAIndices) || 0;\n  var runBIndices = (runB.glyphIndices || []).map(function (i) {\n    return i + runALastIndex + 1;\n  });\n  var glyphIndices = normalize(runAIndices.concat(runBIndices));\n  return Object.assign({}, runA, {\n    end: end,\n    glyphs: glyphs,\n    positions: positions,\n    attributes: attributes,\n    glyphIndices: glyphIndices\n  });\n};\n\n/**\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Insert glyph to run in the given index\r\n *\r\n * @param {number} index index\r\n * @param {Glyph} glyph glyph\r\n * @param {Run} run run\r\n * @returns {Run} run with glyph\r\n */\nvar insertGlyph$1 = function insertGlyph(index, glyph, run) {\n  if (!glyph) return run;\n\n  // Split resolves ligature splitting in case new glyph breaks some\n  var leadingRun = slice$1(0, index, run);\n  var trailingRun = slice$1(index, Infinity, run);\n  return concat(append$1(glyph, leadingRun), trailingRun);\n};\n\n/**\r\n * Insert either glyph or code point to run in the given index\r\n *\r\n * @param {number} index index\r\n * @param {Glyph | number} value glyph or codePoint\r\n * @param {Run} run run\r\n * @returns {Run} run with glyph\r\n */\nvar insert = function insert(index, value, run) {\n  var font = getFont(run);\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return insertGlyph$1(index, glyph, run);\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Get run index at char index\r\n *\r\n * @param {number} n char index\r\n * @param {AttributedString} string attributed string\r\n * @returns {number} run index\r\n */\nvar runIndexAt = function runIndexAt(n, string) {\n  return runIndexAt$1(n, string.runs);\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n */\n\n/**\r\n * Insert glyph into attributed string\r\n *\r\n * @param {number} index index\r\n * @param {Glyph} glyph glyph\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {AttributedString} attributed string with new glyph\r\n */\nvar insertGlyph = function insertGlyph(index, glyph, attributedString) {\n  var runIndex = runIndexAt(index, attributedString);\n\n  // Add glyph to the end if run index invalid\n  if (runIndex === -1) return append(glyph, attributedString);\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  var string = attributedString.string.slice(0, index) + stringFromCodePoints(codePoints) + attributedString.string.slice(index);\n  var runs = attributedString.runs.map(function (run, i) {\n    if (i === runIndex) return insert(index - run.start, glyph, run);\n    if (i > runIndex) return add(codePoints.length, run);\n    return run;\n  });\n  return Object.assign({}, attributedString, {\n    string: string,\n    runs: runs\n  });\n};\n\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\n\n/**\r\n * Advance width between two string indices\r\n *\r\n * @param {number} start glyph index\r\n * @param {number} end glyph index\r\n * @param {Run} run run\r\n * @returns {number} advanced width run\r\n */\nvar advanceWidthBetween$1 = function advanceWidthBetween(start, end, run) {\n  var runStart = run.start || 0;\n  var glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n  var glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n  var positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n  return advanceWidth$2(positions);\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Advance width between start and end\r\n * Does not consider ligature splitting for the moment.\r\n * Check performance impact on supporting this\r\n *\r\n * @param {number} start offset\r\n * @param {number} end offset\r\n * @param {AttributedString} attributedString\r\n * @returns {number} advance width\r\n */\nvar advanceWidthBetween = function advanceWidthBetween(start, end, attributedString) {\n  var runs = filter(start, end, attributedString.runs);\n  return runs.reduce(function (acc, run) {\n    return acc + advanceWidthBetween$1(start, end, run);\n  }, 0);\n};\n\n/**\r\n * @typedef {import('../../types.js').AttributedString} AttributedString\r\n * @typedef {import('../../types.js').Attributes} Attributes\r\n */\n\nvar HYPHEN = 0x002d;\nvar TOLERANCE_STEPS = 5;\nvar TOLERANCE_LIMIT = 50;\nvar opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n\n/**\r\n * Slice attributed string to many lines\r\n *\r\n * @param {AttributedString} string attributed string\r\n * @param {Object[]} nodes\r\n * @param {Object[]} breaks\r\n * @returns {AttributedString[]} attributed strings\r\n */\nvar breakLines = function breakLines(string, nodes, breaks) {\n  var start = 0;\n  var end = null;\n  var lines = breaks.reduce(function (acc, breakPoint) {\n    var node = nodes[breakPoint.position];\n    var prevNode = nodes[breakPoint.position - 1];\n\n    // Last breakpoint corresponds to K&P mandatory final glue\n    if (breakPoint.position === nodes.length - 1) return acc;\n    var line;\n    if (node.type === 'penalty') {\n      end = prevNode.value.end;\n      line = slice(start, end, string);\n      line = insertGlyph(line.length, HYPHEN, line);\n    } else {\n      end = node.value.end;\n      line = slice(start, end, string);\n    }\n    start = end;\n    return [].concat(acc, [line]);\n  }, []);\n\n  // Last line\n  lines.push(slice(start, string.string.length, string));\n  return lines;\n};\n\n/**\r\n * Return Knuth & Plass nodes based on line and previously calculated syllables\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @param {Object} args attributed string args\r\n * @param {Object} options layout options\r\n * @returns {Object[]} attributed strings\r\n */\nvar getNodes = function getNodes(attributedString, _ref, options) {\n  var align = _ref.align;\n  var start = 0;\n  var hyphenWidth = 5;\n  var syllables = attributedString.syllables;\n  var hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  var result = syllables.reduce(function (acc, s, index) {\n    var width = advanceWidthBetween(start, start + s.length, attributedString);\n    if (s.trim() === '') {\n      var stretch = width * opts.width / opts.stretch;\n      var shrink = width * opts.width / opts.shrink;\n      var value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(linebreak.glue(width, value, stretch, shrink));\n    } else {\n      var hyphenated = syllables[index + 1] !== ' ';\n      var _value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(linebreak.box(width, _value, hyphenated));\n      if (syllables[index + 1] && hyphenated) {\n        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n    start += s.length;\n    return acc;\n  }, []);\n  result.push(linebreak.glue(0, null, linebreak.infinity, 0));\n  result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n  return result;\n};\n\n/**\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {Attributes} styles\r\n */\nvar getStyles = function getStyles(attributedString) {\n  var _attributedString$run, _attributedString$run2;\n  return ((_attributedString$run = attributedString.runs) === null || _attributedString$run === void 0 ? void 0 : (_attributedString$run2 = _attributedString$run[0]) === null || _attributedString$run2 === void 0 ? void 0 : _attributedString$run2.attributes) || {};\n};\n\n/**\r\n * Performs Knuth & Plass line breaking algorithm\r\n * Fallbacks to best fit algorithm if latter not successful\r\n *\r\n * @param {Object} options layout options\r\n */\nvar linebreaker = function linebreaker(options) {\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @param {number[]} availableWidths available widths\r\n   * @returns {AttributedString[]} attributed strings\r\n   */\n  return function (attributedString, availableWidths) {\n    var tolerance = options.tolerance || 4;\n    var style = getStyles(attributedString);\n    var nodes = getNodes(attributedString, style, options);\n\n    /** @type {Object[]} */\n    var breaks = linebreak(nodes, availableWidths, {\n      tolerance: tolerance\n    });\n\n    // Try again with a higher tolerance if the line breaking failed.\n    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n      tolerance += TOLERANCE_STEPS;\n      breaks = linebreak(nodes, availableWidths, {\n        tolerance: tolerance\n      });\n    }\n    if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {\n      breaks = applyBestFit(nodes, availableWidths);\n    }\n    return breakLines(attributedString, nodes, breaks.slice(1));\n  };\n};\nvar WHITESPACE_PRIORITY = 1;\nvar LETTER_PRIORITY = 2;\nvar EXPAND_WHITESPACE_FACTOR = {\n  before: 0.5,\n  after: 0.5,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar EXPAND_CHAR_FACTOR = {\n  before: 0.14453125,\n  // 37/256\n  after: 0.14453125,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_WHITESPACE_FACTOR = {\n  before: -0.04296875,\n  // -11/256\n  after: -0.04296875,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_CHAR_FACTOR = {\n  before: -0.04296875,\n  after: -0.04296875,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nvar getCharFactor = function getCharFactor(direction, options) {\n  var expandCharFactor = options.expandCharFactor || {};\n  var shrinkCharFactor = options.shrinkCharFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\nvar getWhitespaceFactor = function getWhitespaceFactor(direction, options) {\n  var expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n  var shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\nvar factor = function factor(direction, options) {\n  return function (glyphs) {\n    var charFactor = getCharFactor(direction, options);\n    var whitespaceFactor = getWhitespaceFactor(direction, options);\n    var factors = [];\n    for (var index = 0; index < glyphs.length; index += 1) {\n      var f = void 0;\n      var glyph = glyphs[index];\n      if (isWhiteSpace(glyph)) {\n        f = Object.assign({}, whitespaceFactor);\n        if (index === glyphs.length - 1) {\n          f.before = 0;\n          if (index > 0) {\n            factors[index - 1].after = 0;\n          }\n        }\n      } else if (glyph.isMark && index > 0) {\n        f = Object.assign({}, factors[index - 1]);\n        f.before = 0;\n        factors[index - 1].after = 0;\n      } else {\n        f = Object.assign({}, charFactor);\n      }\n      factors.push(f);\n    }\n    return factors;\n  };\n};\nvar getFactors = function getFactors(gap, line, options) {\n  var direction = gap > 0 ? 'GROW' : 'SHRINK';\n  var getFactor = factor(direction, options);\n  var factors = line.runs.reduce(function (acc, run) {\n    return acc.concat(getFactor(run.glyphs));\n  }, []);\n  factors[0].before = 0;\n  factors[factors.length - 1].after = 0;\n  return factors;\n};\n\n/* eslint-disable no-multi-assign */\nvar KASHIDA_PRIORITY = 0;\nvar NULL_PRIORITY = 3;\nvar getDistances = function getDistances(gap, factors) {\n  var total = 0;\n  var priorities = [];\n  var unconstrained = [];\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {\n    priorities[_priority] = unconstrained[_priority] = 0;\n  }\n\n  // sum the factors at each priority\n  for (var j = 0; j < factors.length; j += 1) {\n    var f = factors[j];\n    var sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  }\n\n  // choose the priorities that need to be applied\n  var highestPriority = -1;\n  var highestPrioritySum = 0;\n  var remainingGap = gap;\n  var priority;\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    var prioritySum = priorities[priority];\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      }\n\n      // if this priority covers the remaining gap, we're done\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      }\n\n      // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n      priorities[priority] = 1;\n      remainingGap -= prioritySum;\n\n      // if this priority has unconstrained glyphs, let them consume the remaining space\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  }\n\n  // zero out remaining priorities (if any)\n  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  }\n\n  // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  }\n\n  // create and return an array of distances to add to each glyph's advance\n  var distances = [];\n  for (var index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    var _f = factors[index];\n    var next = factors[index + 1];\n    var dist = _f.after * priorities[_f.priority];\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    }\n\n    // if this glyph is unconstrained, add the unconstrained distance as well\n    if (_f.unconstrained) {\n      dist += _f.after * unconstrained[_f.priority];\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n    distances.push(dist);\n  }\n  return distances;\n};\n\n/**\r\n * Adjust run positions by given distances\r\n *\r\n * @param {number[]} distances\r\n * @param {Object} line\r\n * @returns {Object} line\r\n */\nvar justifyLine = function justifyLine(distances, line) {\n  var index = 0;\n  for (var _iterator = _createForOfIteratorHelperLoose(line.runs), _step; !(_step = _iterator()).done;) {\n    var run = _step.value;\n    for (var _iterator2 = _createForOfIteratorHelperLoose(run.positions), _step2; !(_step2 = _iterator2()).done;) {\n      var position = _step2.value;\n      position.xAdvance += distances[index++];\n    }\n  }\n  return line;\n};\n\n/**\r\n * A JustificationEngine is used by a Typesetter to perform line fragment\r\n * justification. This implementation is based on a description of Apple's\r\n * justification algorithm from a PDF in the Apple Font Tools package.\r\n *\r\n * // TODO: Make it immutable\r\n *\r\n * @param {Object} options layout options\r\n */\nvar justification = function justification(options) {\n  /**\r\n   * @param {Object} line\r\n   * @returns {Object} line\r\n   */\n  return function (line) {\n    var gap = line.box.width - advanceWidth(line);\n    if (gap === 0) return; // Exact fit\n\n    var factors = getFactors(gap, line, options);\n    var distances = getDistances(gap, factors);\n    return justifyLine(distances, line);\n  };\n};\n\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Returns attributed string ascent\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} ascent\r\n */\nvar ascent = function ascent(attributedString) {\n  var reducer = function reducer(acc, run) {\n    return Math.max(acc, ascent$1(run));\n  };\n  return attributedString.runs.reduce(reducer, 0);\n};\n\n/* eslint-disable no-param-reassign */\n\n// The base font size used for calculating underline thickness.\nvar BASE_FONT_SIZE = 12;\n\n/**\r\n * A TextDecorationEngine is used by a Typesetter to generate\r\n * DecorationLines for a line fragment, including underlines\r\n * and strikes.\r\n */\nvar textDecoration = function textDecoration() {\n  return function (lineFragment) {\n    var x = lineFragment.overflowLeft || 0;\n    var overflowRight = lineFragment.overflowRight || 0;\n    var maxX = advanceWidth(lineFragment) - overflowRight;\n    lineFragment.decorationLines = [];\n    for (var i = 0; i < lineFragment.runs.length; i += 1) {\n      var run = lineFragment.runs[i];\n      var width = Math.min(maxX - x, advanceWidth$1(run));\n      var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n      if (run.attributes.underline) {\n        var rect = {\n          x: x,\n          y: ascent(lineFragment) + thickness * 2,\n          width: width,\n          height: thickness\n        };\n        var line = {\n          rect: rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.underlineColor || 'black',\n          style: run.attributes.underlineStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(line);\n      }\n      if (run.attributes.strike) {\n        var y = ascent(lineFragment) - ascent$1(run) / 3;\n        var _rect = {\n          x: x,\n          y: y,\n          width: width,\n          height: thickness\n        };\n        var _line = {\n          rect: _rect,\n          opacity: run.attributes.opacity,\n          color: run.attributes.strikeColor || 'black',\n          style: run.attributes.strikeStyle || 'solid'\n        };\n        lineFragment.decorationLines.push(_line);\n      }\n      x += width;\n    }\n    return lineFragment;\n  };\n};\nvar ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n\n/**\r\n * @typedef {import('../../types.js').AttributedString} AttributedString\r\n */\n\n/**\r\n * Resolves unicode script in runs, grouping equal runs together\r\n */\nvar scriptItemizer = function scriptItemizer() {\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\n  return function (attributedString) {\n    var string = attributedString.string;\n    var lastScript = 'Unknown';\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n    if (!string) return empty();\n    for (var i = 0; i < string.length; i += 1) {\n      var char = string[i];\n      var codePoint = char.codePointAt();\n      var script = unicode.getScript(codePoint);\n      if (script !== lastScript && !ignoredScripts.includes(script)) {\n        if (lastScript !== 'Unknown') {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              script: lastScript\n            }\n          });\n        }\n        lastIndex = index;\n        lastScript = script;\n      }\n      index += char.length;\n    }\n    if (lastIndex < string.length) {\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          script: lastScript\n        }\n      });\n    }\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\nvar SOFT_HYPHEN = \"\\xAD\";\nvar hyphenator = hyphen(pattern);\n\n/**\r\n * @param {string} word\r\n * @returns {string[]} word parts\r\n */\nvar splitHyphen = function splitHyphen(word) {\n  return word.split(SOFT_HYPHEN);\n};\nvar cache = {};\n\n/**\r\n * @param {string} word\r\n * @returns {string[]} word parts\r\n */\nvar getParts = function getParts(word) {\n  var base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n  return splitHyphen(base);\n};\nvar wordHyphenation = function wordHyphenation() {\n  /**\r\n   * @param {string} word word\r\n   * @returns {string[]} word parts\r\n   */\n  return function (word) {\n    var cacheKey = \"_\" + word;\n    if (isNil(word)) return [];\n    if (cache[cacheKey]) return cache[cacheKey];\n    cache[cacheKey] = getParts(word);\n    return cache[cacheKey];\n  };\n};\n\n/**\r\n * @typedef {import('../../types.js').AttributedString} AttributedString\r\n * @typedef {import('../../types.js').Run} Run\r\n */\n\n/**\r\n * @param {Run} run run\r\n * @returns {number}\r\n */\nvar getFontSize = function getFontSize(run) {\n  return run.attributes.fontSize || 12;\n};\n\n/**\r\n * Resolve font runs in an AttributedString, grouping equal\r\n * runs and performing font substitution where necessary.\r\n */\nvar fontSubstitution = function fontSubstitution() {\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\n  return function (attributedString) {\n    var string = attributedString.string,\n      runs = attributedString.runs;\n    var lastFont = null;\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n    if (!string) return empty();\n    for (var _iterator = _createForOfIteratorHelperLoose(runs), _step; !(_step = _iterator()).done;) {\n      var run = _step.value;\n      var _fontSize = getFontSize(run);\n      var defaultFont = run.attributes.font;\n      if (string.length === 0) {\n        res.push({\n          start: 0,\n          end: 0,\n          attributes: {\n            font: defaultFont\n          }\n        });\n        break;\n      }\n      for (var _iterator2 = _createForOfIteratorHelperLoose(string.slice(run.start, run.end)), _step2; !(_step2 = _iterator2()).done;) {\n        var char = _step2.value;\n        var font = defaultFont;\n        if (font !== lastFont) {\n          if (lastFont) {\n            res.push({\n              start: lastIndex,\n              end: index,\n              attributes: {\n                font: lastFont,\n                scale: lastFont ? _fontSize / lastFont.unitsPerEm : 0\n              }\n            });\n          }\n          lastFont = font;\n          lastIndex = index;\n        }\n        index += char.length;\n      }\n    }\n    if (lastIndex < string.length) {\n      var fontSize = getFontSize(last(runs));\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          font: lastFont,\n          scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n        }\n      });\n    }\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\nexport { bidiEngine as bidi, layoutEngine as default, fontSubstitution, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };","map":{"version":3,"names":["isNil","last","repeat","dropLast","dropLast$2","adjust","compose","_extends","_objectWithoutPropertiesLoose","bidiFactory","_createForOfIteratorHelperLoose","unicode","hyphen","pattern","fromFragments","fragments","offset","string","runs","forEach","fragment","push","start","end","length","attributes","defaultHyphenationEngine","word","wrapWords","engines","options","attributedString","_engines$wordHyphenat","_engines","syllables","hyphenateWord","hyphenationCallback","wordHyphenation","call","i","run","words","slice","split","filter","Boolean","j","parts","apply","join","copy","rect","Object","assign","partition","height","a","b","y","crop","_partition","result","height$2","paragraph","reduce","acc","block","box","calculateScale","_attributes$font","fontSize","unitsPerEm","font","scale","_run$attributes","index","glyphIndices","value","getFont","slice$2","glyph","codePoints","String","fromCodePoint","layout","undefined","glyphs","glyphIndexAt","_run$glyphIndices","normalize","array","head","map","slice$1","_run$glyphs","_run$glyphs2","runScale","startIndex","endIndex","startGlyph","endGlyph","startOffset","startGlyphs","Infinity","endOffset","endGlyphs","sliceStart","Math","min","glyphPosition","g","xAdvance","advanceWidth","startPositions","positions","endPositions","flat","runIndexAt$1","runIndexAt","n","findIndex","max","subtract","sliceRuns","sliceFirstRun","sliceLastRun","isFirst","isLast","filteredRuns","slicedRuns","findCharIndex","search","findLastCharIndex","match","lastIndexOf","trim","empty$1","empty","isNumber","appendIndices","indices","lastIndex","newIndices","Array","fill","concat","glyphForCodePoint","appendGlyph","_glyph$codePoints","glyphLength","append$1","append","stringFromCodePoints","codePointsString","firstRuns","lastRun","ELLIPSIS_UNICODE","ELLIPSIS_STRING","fromCharCode","getEllipsisCodePoint","encode","_font$encode","parseInt","truncate","_last","_last2","_last2$attributes","_Object$assign","codePoint","lastBlock","omit","ascent$1","ascent","_run$attributes$attac","_run$attributes2","_run$attributes2$font","attachmentHeight","attachment","fontAscent","descent","_run$attributes$font","fontDescent","lineGap","height$1","lineHeight","reducer","intersects","x","num1","width","num2","_excluded","getLineFragment","lineRect","excludeRect","eStart","eEnd","lStart","lEnd","r","getLineFragments","excludeRects","_loop","pieces","generateLineRects","container","lineRects","maxY","currentRect","rest","lineRectFragments","ATTACHMENT_CODE$1","purgeAttachments","shouldPurge","includes","layoutLines","rects","lines","indent","shift","currentY","line","_line$runs","_line$runs$","lineIndent","style","newLine","layoutParagraph","_paragraph$runs","_paragraph$runs$","_paragraph$runs$$attr","availableWidths","linebreaker","sliceAtHeight","newBlock","counter","typesetter","attributedStrings","blocks","paragraphs","layoutBlock","maxLines","truncateEllipsis","truncateMode","linesCount","paragraphRect","nextParagraph","slicedBlock","linesHeight","shouldTruncate","length$1","bidi$2","getBidiLevels$1","getBidiLevels","levels","bidiLevel","getReorderedIndices","segments","_ref","_i","getItemAtIndex","objectName","updatedIndex","Error","reorderLine","_attributedString$run","direction","level","embeddingLevels","getReorderSegments","updatedString","getReorderedString","updatedRuns","selectedIndices","updatedGlyphs","updatedPositions","addedGlyphs","Set","has","id","isLigature","add","reorderParagraph","bidiReordering","DUMMY_CODEPOINT","resolve","next","getCharacterSpacing","characterSpacing","scalePositions","position","xSpacing","yAdvance","xOffset","yOffset","layoutRun","runString","glyphRun","generateGlyphs","resolveRunYOffset","p","resolveYOffset","sort","isEmpty","sortPoints","generatePoints","mergeRuns","groupEmptyRuns","groups","values","flattenEmptyRuns","flattenRegularRuns","res","points","attrs","stack","_points$i","type","splice","flatten","emptyRuns","regularRuns","omitFont","preprocessRuns","fontSubstitution","scriptItemizer","bidi","_omitFont","omittedFontRuns","_scriptItemizer","itemizationRuns","_fontSubstitution","substitutedRuns","_bidi","bidiRuns","splitParagraphs","breakPoint","indexOf","advanceWidth$2","pos","advanceWidth$1","WHITE_SPACES_CODE","isWhiteSpace","leadingPositions","leadingWhitespaces","leadingOffset$1","leadingOffset","reverse","trailingPositions","trailingOffset$1","trailingOffset","dropLast$1","ALIGNMENT_FACTORS","center","right","removeNewLine","getOverflowLeft","overflowLeft","getOverflowRight","overflowRight","adjustOverflow","justifyLine$1","justifyLine","align","lineWidth","alignFactor","remainingWidth","shouldJustify","justification","finalizeLine","lineAscent","lineDescent","lineXAdvance","descent$1","finalizeBlock","isLastFragment","alignLastLine","textDecoration","finalizeFragments","blockFinalizer","ATTACHMENT_CODE","isReplaceGlyph","resolveRunAttachments","resolveAttachments","applyAttributes","backgroundColor","bullet","color","features","hangingPunctuation","hyphenationFactor","justificationFactor","lineSpacing","link","marginLeft","margin","marginRight","opacity","paddingTop","padding","paragraphSpacing","script","shrinkFactor","strike","strikeColor","strikeStyle","stroke","underline","underlineColor","underlineStyle","verticalAlign","wordSpacing","applyRunStyles","applyDefaultStyles","verticalAlignment","bidi$1","mirrorString","char","isRTL","mirroredChar","getMirroredCharacter","charAt","layoutEngine","processParagraph","processParagraphs","bidiEngine","_bidi$getEmbeddingLev","getEmbeddingLevels","lastLevel","INFINITY","getNextBreakpoint","subnodes","widths","lineNumber","minimumBadness","sum","stretch","shrink","lineLength","calculateRatio","node","ratio","penalty","badness","pow","abs","applyBestFit","nodes","count","breakpoints","breakpoint","Node","data","prev","_proto","prototype","toString","LinkedList","tail","listSize","listLength","_proto2","isLinked","size","first","toArray","fun","contains","at","insertAfter","newNode","insertBefore","unshift","remove","pop","linebreak","settings","demerits","flagged","fitness","tolerance","activeNodes","lineLengths","breaks","tmp","fitnessClass","totals","previous","computeCost","active","currentLine","infinity","computeSum","breakPointIndex","mainLoop","candidates","tmpSum","currentClass","candidate","glue","hyphenated","runA","runB","runAIndices","runALastIndex","runBIndices","insertGlyph$1","insertGlyph","leadingRun","trailingRun","insert","runIndex","advanceWidthBetween$1","advanceWidthBetween","runStart","glyphStartIndex","glyphEndIndex","HYPHEN","TOLERANCE_STEPS","TOLERANCE_LIMIT","opts","breakLines","prevNode","getNodes","hyphenWidth","hyphenPenalty","hyphenationPenalty","s","_value","getStyles","_attributedString$run2","WHITESPACE_PRIORITY","LETTER_PRIORITY","EXPAND_WHITESPACE_FACTOR","before","after","priority","unconstrained","EXPAND_CHAR_FACTOR","SHRINK_WHITESPACE_FACTOR","SHRINK_CHAR_FACTOR","getCharFactor","expandCharFactor","shrinkCharFactor","getWhitespaceFactor","expandWhitespaceFactor","shrinkWhitespaceFactor","factor","charFactor","whitespaceFactor","factors","f","isMark","getFactors","gap","getFactor","KASHIDA_PRIORITY","NULL_PRIORITY","getDistances","total","priorities","_priority","highestPriority","highestPrioritySum","remainingGap","prioritySum","distances","_f","dist","_iterator","_step","done","_iterator2","_step2","BASE_FONT_SIZE","lineFragment","maxX","decorationLines","thickness","floor","_rect","_line","ignoredScripts","lastScript","codePointAt","getScript","SOFT_HYPHEN","hyphenator","splitHyphen","cache","getParts","base","cacheKey","getFontSize","lastFont","_fontSize","defaultFont","default"],"sources":["D:/SLIIT IT/Year 2 semster 2/ITP/Project/Smart TechHub Management System/New-Gen-/mern-admin/node_modules/@react-pdf/textkit/lib/textkit.js"],"sourcesContent":["import { isNil, last, repeat, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\r\nimport _extends from '@babel/runtime/helpers/extends';\r\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\r\nimport bidiFactory from 'bidi-js';\r\nimport _createForOfIteratorHelperLoose from '@babel/runtime/helpers/createForOfIteratorHelperLoose';\r\nimport unicode from 'unicode-properties';\r\nimport hyphen from 'hyphen';\r\nimport pattern from 'hyphen/patterns/en-us.js';\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Fragment} Fragment\r\n */\r\n\r\n/**\r\n * Create attributed string from text fragments\r\n *\r\n * @param {Fragment[]} fragments fragments\r\n * @returns {AttributedString} attributed string\r\n */\r\nvar fromFragments = function fromFragments(fragments) {\r\n  var offset = 0;\r\n  var string = '';\r\n  var runs = [];\r\n  fragments.forEach(function (fragment) {\r\n    string += fragment.string;\r\n    runs.push(_extends({}, fragment, {\r\n      start: offset,\r\n      end: offset + fragment.string.length,\r\n      attributes: fragment.attributes || {}\r\n    }));\r\n    offset += fragment.string.length;\r\n  });\r\n  return {\r\n    string: string,\r\n    runs: runs\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Default word hyphenation engine used when no one provided.\r\n * Does not perform word hyphenation at all\r\n *\r\n * @param {string} word\r\n * @returns {[string]} same word\r\n */\r\nvar defaultHyphenationEngine = function defaultHyphenationEngine(word) {\r\n  return [word];\r\n};\r\n\r\n/**\r\n * Wrap words of attribute string\r\n *\r\n * @param {Object} engines layout engines\r\n * @param {Object} options layout options\r\n */\r\nvar wrapWords = function wrapWords(engines, options) {\r\n  if (engines === void 0) {\r\n    engines = {};\r\n  }\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string including syllables\r\n   */\r\n  return function (attributedString) {\r\n    var _engines$wordHyphenat, _engines;\r\n    var syllables = [];\r\n    var fragments = [];\r\n    var hyphenateWord = options.hyphenationCallback || ((_engines$wordHyphenat = (_engines = engines).wordHyphenation) === null || _engines$wordHyphenat === void 0 ? void 0 : _engines$wordHyphenat.call(_engines, options)) || defaultHyphenationEngine;\r\n    for (var i = 0; i < attributedString.runs.length; i += 1) {\r\n      var string = '';\r\n      var run = attributedString.runs[i];\r\n      var words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\r\n      for (var j = 0; j < words.length; j += 1) {\r\n        var word = words[j];\r\n        var parts = hyphenateWord(word);\r\n        syllables.push.apply(syllables, parts);\r\n        string += parts.join('');\r\n      }\r\n      fragments.push(_extends({}, run, {\r\n        string: string\r\n      }));\r\n    }\r\n    return _extends({}, fromFragments(fragments), {\r\n      syllables: syllables\r\n    });\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\r\n\r\n/**\r\n * Clone rect\r\n *\r\n * @param {Rect} rect rect\r\n * @returns {Rect} cloned rect\r\n */\r\nvar copy = function copy(rect) {\r\n  return Object.assign({}, rect);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\r\n\r\n/**\r\n *\r\n * @param {Rect} rect rect\r\n * @param {number} height height\r\n * @returns {[Rect, Rect]} partitioned rects\r\n */\r\nvar partition = function partition(rect, height) {\r\n  var a = Object.assign({}, rect, {\r\n    height: height\r\n  });\r\n  var b = Object.assign({}, rect, {\r\n    y: rect.y + height,\r\n    height: rect.height - height\r\n  });\r\n  return [a, b];\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\r\n\r\n/**\r\n * Crop upper section of rect\r\n *\r\n * @param {number} height height\r\n * @param {Rect} rect rect\r\n * @returns {Rect} cropped rect\r\n */\r\nvar crop = function crop(height, rect) {\r\n  var _partition = partition(rect, height),\r\n    result = _partition[1];\r\n  return result;\r\n};\r\n\r\n/**\r\n * Get paragraph block height\r\n *\r\n * @param {Object}  paragraph block\r\n * @returns {number} paragraph block height\r\n */\r\nvar height$2 = function height(paragraph) {\r\n  return paragraph.reduce(function (acc, block) {\r\n    return acc + block.box.height;\r\n  }, 0);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Calculate run scale\r\n *\r\n * @param {Run} run run\r\n * @returns {number} scale\r\n */\r\nvar calculateScale = function calculateScale(run) {\r\n  var _attributes$font;\r\n  var attributes = run.attributes || {};\r\n  var fontSize = attributes.fontSize || 12;\r\n  var unitsPerEm = (_attributes$font = attributes.font) === null || _attributes$font === void 0 ? void 0 : _attributes$font.unitsPerEm;\r\n  return unitsPerEm ? fontSize / unitsPerEm : 0;\r\n};\r\n\r\n/**\r\n * Get run scale\r\n *\r\n * @param {Object}  run\r\n * @returns {number} scale\r\n */\r\nvar scale = function scale(run) {\r\n  var _run$attributes;\r\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.scale) || calculateScale(run);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Get ligature offset by index\r\n *\r\n * Ex. ffi ligature\r\n *\r\n *   glyphs:         l  o  f  f  i  m\r\n *   glyphIndices:   0  1  2  2  2  3\r\n *   offset:         0  0  0  1  2  0\r\n *\r\n * @param {number} index\r\n * @param {Run} run run\r\n * @returns {number} ligature offset\r\n */\r\nvar offset = function offset(index, run) {\r\n  if (!run) return 0;\r\n  var glyphIndices = run.glyphIndices || [];\r\n  var value = glyphIndices[index];\r\n  return glyphIndices.slice(0, index).filter(function (i) {\r\n    return i === value;\r\n  }).length;\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Font} Font\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Get run font\r\n *\r\n * @param {Run} run run\r\n * @returns {Font | null} font\r\n */\r\nvar getFont = function getFont(run) {\r\n  var _run$attributes;\r\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.font) || null;\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Font} Font\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n */\r\n\r\n/**\r\n * Slice glyph between codePoints range\r\n * Util for breaking ligatures\r\n *\r\n * @param {number} start start code point index\r\n * @param {number} end end code point index\r\n * @param {Font} font font to generate new glyph\r\n * @param {Glyph} glyph glyph to be sliced\r\n * @returns {Glyph[]} sliced glyph parts\r\n */\r\nvar slice$2 = function slice(start, end, font, glyph) {\r\n  if (!glyph) return [];\r\n  if (start === end) return [];\r\n  if (start === 0 && end === glyph.codePoints.length) return [glyph];\r\n  var codePoints = glyph.codePoints.slice(start, end);\r\n  var string = String.fromCodePoint.apply(String, codePoints);\r\n\r\n  // passing LTR To force fontkit to not reverse the string\r\n  return font ? font.layout(string, undefined, undefined, undefined, 'ltr').glyphs : [glyph];\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Return glyph index at string index, if glyph indices present.\r\n * Otherwise return string index\r\n *\r\n * @param {number} index index\r\n * @param {Run} run run\r\n * @returns {number} glyph index\r\n */\r\nvar glyphIndexAt = function glyphIndexAt(index, run) {\r\n  var _run$glyphIndices;\r\n  var result = run === null || run === void 0 ? void 0 : (_run$glyphIndices = run.glyphIndices) === null || _run$glyphIndices === void 0 ? void 0 : _run$glyphIndices[index];\r\n  return isNil(result) ? index : result;\r\n};\r\n\r\n/**\r\n * Returns new array starting with zero, and keeping same relation between consecutive values\r\n *\r\n * @param {number[]} array list\r\n * @returns {number[]} normalized array\r\n */\r\nvar normalize = function normalize(array) {\r\n  var head = array[0];\r\n  return array.map(function (value) {\r\n    return value - head;\r\n  });\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Slice run between glyph indices range\r\n *\r\n * @param {number} start glyph index\r\n * @param {number} end glyph index\r\n * @param {Run} run run\r\n * @returns {Run} sliced run\r\n */\r\nvar slice$1 = function slice(start, end, run) {\r\n  var _run$glyphs, _run$glyphs2;\r\n  var runScale = scale(run);\r\n  var font = getFont(run);\r\n\r\n  // Get glyph start and end indices\r\n  var startIndex = glyphIndexAt(start, run);\r\n  var endIndex = glyphIndexAt(end, run);\r\n\r\n  // Get start and end glyph\r\n  var startGlyph = (_run$glyphs = run.glyphs) === null || _run$glyphs === void 0 ? void 0 : _run$glyphs[startIndex];\r\n  var endGlyph = (_run$glyphs2 = run.glyphs) === null || _run$glyphs2 === void 0 ? void 0 : _run$glyphs2[endIndex];\r\n\r\n  // Get start ligature chunks (if any)\r\n  var startOffset = offset(start, run);\r\n  var startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];\r\n\r\n  // Get end ligature chunks (if any)\r\n  var endOffset = offset(end, run);\r\n  var endGlyphs = slice$2(0, endOffset, font, endGlyph);\r\n\r\n  // Compute new glyphs\r\n  var sliceStart = startIndex + Math.min(1, startOffset);\r\n  var glyphs = (run.glyphs || []).slice(sliceStart, endIndex);\r\n\r\n  // Compute new positions\r\n  var glyphPosition = function glyphPosition(g) {\r\n    return {\r\n      xAdvance: g.advanceWidth * runScale\r\n    };\r\n  };\r\n  var startPositions = startGlyphs.map(glyphPosition);\r\n  var positions = (run.positions || []).slice(sliceStart, endIndex);\r\n  var endPositions = endGlyphs.map(glyphPosition);\r\n  return Object.assign({}, run, {\r\n    start: run.start + start,\r\n    end: Math.min(run.end, run.start + end),\r\n    glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\r\n    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\r\n    positions: [startPositions, positions, endPositions].flat()\r\n  });\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Get run index that contains passed index\r\n *\r\n * @param {number} n index\r\n * @param {Run[]} runs runs\r\n * @returns {number} run index\r\n */\r\nvar runIndexAt$1 = function runIndexAt(n, runs) {\r\n  if (!runs) return -1;\r\n  return runs.findIndex(function (run) {\r\n    return run.start <= n && n < run.end;\r\n  });\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Filter runs contained between start and end\r\n *\r\n * @param {number} start\r\n * @param {number} end\r\n * @param {Run[]} runs\r\n * @returns {Run[]} filtered runs\r\n */\r\nvar filter = function filter(start, end, runs) {\r\n  var startIndex = runIndexAt$1(start, runs);\r\n  var endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\r\n  return runs.slice(startIndex, endIndex + 1);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Subtract scalar to run\r\n *\r\n * @param {number} n scalar\r\n * @param {Run} run run\r\n * @returns {Object} subtracted run\r\n */\r\nvar subtract = function subtract(n, run) {\r\n  var start = run.start - n;\r\n  var end = run.end - n;\r\n  return Object.assign({}, run, {\r\n    start: start,\r\n    end: end\r\n  });\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Slice array of runs\r\n *\r\n * @param {number} start offset\r\n * @param {number} end offset\r\n * @param {Run[]} runs\r\n * @returns {Run[]} sliced runs\r\n */\r\nvar sliceRuns = function sliceRuns(start, end, runs) {\r\n  var sliceFirstRun = function sliceFirstRun(a) {\r\n    return slice$1(start - a.start, end - a.start, a);\r\n  };\r\n  var sliceLastRun = function sliceLastRun(a) {\r\n    return slice$1(0, end - a.start, a);\r\n  };\r\n  return runs.map(function (run, i) {\r\n    var result = run;\r\n    var isFirst = i === 0;\r\n    var isLast = !isFirst && i === runs.length - 1;\r\n    if (isFirst) result = sliceFirstRun(run);\r\n    if (isLast) result = sliceLastRun(run);\r\n    return subtract(start, result);\r\n  });\r\n};\r\n\r\n/**\r\n * Slice attributed string between two indices\r\n *\r\n * @param {number} start offset\r\n * @param {number} end offset\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {AttributedString} attributed string\r\n */\r\nvar slice = function slice(start, end, attributedString) {\r\n  if (attributedString.string.length === 0) return attributedString;\r\n  var string = attributedString.string.slice(start, end);\r\n  var filteredRuns = filter(start, end, attributedString.runs);\r\n  var slicedRuns = sliceRuns(start, end, filteredRuns);\r\n  return Object.assign({}, attributedString, {\r\n    string: string,\r\n    runs: slicedRuns\r\n  });\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * @param {string} string\r\n * @returns {number} index\r\n */\r\nvar findCharIndex = function findCharIndex(string) {\r\n  return string.search(/\\S/g);\r\n};\r\n\r\n/**\r\n * @param {string} string\r\n * @returns {number} index\r\n */\r\nvar findLastCharIndex = function findLastCharIndex(string) {\r\n  var match = string.match(/\\S/g);\r\n  return match ? string.lastIndexOf(match[match.length - 1]) : -1;\r\n};\r\n\r\n/**\r\n * Removes (strips) whitespace from both ends of the attributted string.\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {AttributedString} attributed string\r\n */\r\nvar trim = function trim(attributedString) {\r\n  var start = findCharIndex(attributedString.string);\r\n  var end = findLastCharIndex(attributedString.string);\r\n  return slice(start, end + 1, attributedString);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Returns empty run\r\n *\r\n * @returns {Run} empty run\r\n */\r\nvar empty$1 = function empty() {\r\n  return {\r\n    start: 0,\r\n    end: 0,\r\n    glyphIndices: [],\r\n    glyphs: [],\r\n    positions: [],\r\n    attributes: {}\r\n  };\r\n};\r\n\r\n/**\r\n * Check if value is a number\r\n *\r\n * @template {unknown} T\r\n * @param {T} value Value to check\r\n * @returns {value is number} Whether value is a number\r\n */\r\nvar isNumber = function isNumber(value) {\r\n  return typeof value === 'number';\r\n};\r\n\r\n/**\r\n * Append glyph indices with given length\r\n *\r\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\r\n *\r\n * @param {number} length length\r\n * @param {number[]} indices glyph indices\r\n * @returns {number[]} extended glyph indices\r\n */\r\nvar appendIndices = function appendIndices(length, indices) {\r\n  var lastIndex = last(indices);\r\n  var value = isNil(lastIndex) ? 0 : lastIndex + 1;\r\n  var newIndices = Array(length).fill(value);\r\n  return indices.concat(newIndices);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Font} Font\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n */\r\n\r\n/**\r\n * Get glyph for a given code point\r\n *\r\n * @param {number} [value] codePoint\r\n * @param {Font} [font] font\r\n * @returns {Glyph} glyph\r\n * */\r\nvar fromCodePoint = function fromCodePoint(value, font) {\r\n  return font && value ? font.glyphForCodePoint(value) : null;\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Append glyph to run\r\n *\r\n * @param {Glyph} glyph glyph\r\n * @param {Run} run run\r\n * @returns {Run} run with glyph\r\n */\r\nvar appendGlyph = function appendGlyph(glyph, run) {\r\n  var _glyph$codePoints;\r\n  var glyphLength = ((_glyph$codePoints = glyph.codePoints) === null || _glyph$codePoints === void 0 ? void 0 : _glyph$codePoints.length) || 0;\r\n  var end = run.end + glyphLength;\r\n  var glyphs = run.glyphs.concat(glyph);\r\n  var glyphIndices = appendIndices(glyphLength, run.glyphIndices);\r\n  if (!run.positions) return Object.assign({}, run, {\r\n    end: end,\r\n    glyphs: glyphs,\r\n    glyphIndices: glyphIndices\r\n  });\r\n  var positions = run.positions.concat({\r\n    xAdvance: glyph.advanceWidth * scale(run)\r\n  });\r\n  return Object.assign({}, run, {\r\n    end: end,\r\n    glyphs: glyphs,\r\n    glyphIndices: glyphIndices,\r\n    positions: positions\r\n  });\r\n};\r\n\r\n/**\r\n * Append glyph or code point to run\r\n *\r\n * @param {Glyph | number | undefined} value glyph or codePoint\r\n * @param {Run} run run\r\n * @returns {Run} run with glyph\r\n */\r\nvar append$1 = function append(value, run) {\r\n  if (!value) return run;\r\n  var font = getFont(run);\r\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\r\n  return appendGlyph(glyph, run);\r\n};\r\n\r\n/**\r\n * Get string from array of code points\r\n *\r\n * @param {number[]} codePoints points\r\n * @returns {string} string\r\n */\r\nvar stringFromCodePoints = function stringFromCodePoints(codePoints) {\r\n  return String.fromCodePoint.apply(String, codePoints || []);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n */\r\n\r\n/**\r\n * Append glyph into last run of attributed string\r\n *\r\n * @param {Glyph} glyph glyph\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {AttributedString} attributed string with new glyph\r\n */\r\nvar append = function append(glyph, attributedString) {\r\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\r\n  var codePointsString = stringFromCodePoints(codePoints);\r\n  var string = attributedString.string + codePointsString;\r\n  var firstRuns = attributedString.runs.slice(0, -1);\r\n  var lastRun = last(attributedString.runs) || empty$1();\r\n  var runs = firstRuns.concat(append$1(glyph, lastRun));\r\n  return Object.assign({}, attributedString, {\r\n    string: string,\r\n    runs: runs\r\n  });\r\n};\r\n\r\nvar ELLIPSIS_UNICODE = 8230;\r\nvar ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\r\n\r\n/**\r\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\r\n *\r\n * @param {Object} font\r\n * @returns {Object} ellipsis codepoint\r\n */\r\nvar getEllipsisCodePoint = function getEllipsisCodePoint(font) {\r\n  if (!font.encode) return ELLIPSIS_UNICODE;\r\n  var _font$encode = font.encode(ELLIPSIS_STRING),\r\n    codePoints = _font$encode[0];\r\n  return parseInt(codePoints[0], 16);\r\n};\r\n\r\n/**\r\n * Trucante block with ellipsis\r\n *\r\n * @param {Object} block paragraph block\r\n * @returns {Object} sliced paragraph block\r\n */\r\nvar truncate = function truncate(block) {\r\n  var _last, _last2, _last2$attributes;\r\n  var runs = ((_last = last(block)) === null || _last === void 0 ? void 0 : _last.runs) || [];\r\n  var font = (_last2 = last(runs)) === null || _last2 === void 0 ? void 0 : (_last2$attributes = _last2.attributes) === null || _last2$attributes === void 0 ? void 0 : _last2$attributes.font;\r\n  if (font) {\r\n    var _Object$assign;\r\n    var index = block.length - 1;\r\n    var codePoint = getEllipsisCodePoint(font);\r\n    var glyph = font.glyphForCodePoint(codePoint);\r\n    var lastBlock = append(glyph, trim(block[index]));\r\n    return Object.assign([], block, (_Object$assign = {}, _Object$assign[index] = lastBlock, _Object$assign));\r\n  }\r\n  return block;\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Attributes} Attributes\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Omit attribute from run\r\n *\r\n * @param {keyof Attributes} value attribute value\r\n * @param {Run} run run\r\n * @returns {Run} run without ommited attribute\r\n */\r\nvar omit = function omit(value, run) {\r\n  var attributes = Object.assign({}, run.attributes);\r\n  delete attributes[value];\r\n  return Object.assign({}, run, {\r\n    attributes: attributes\r\n  });\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Get run ascent\r\n *\r\n * @param {Run} run run\r\n * @returns {number} ascent\r\n */\r\nvar ascent$1 = function ascent(run) {\r\n  var _run$attributes, _run$attributes$attac, _run$attributes2, _run$attributes2$font;\r\n  var attachmentHeight = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$attac = _run$attributes.attachment) === null || _run$attributes$attac === void 0 ? void 0 : _run$attributes$attac.height) || 0;\r\n  var fontAscent = ((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : (_run$attributes2$font = _run$attributes2.font) === null || _run$attributes2$font === void 0 ? void 0 : _run$attributes2$font.ascent) || 0;\r\n  return Math.max(attachmentHeight, fontAscent * scale(run));\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Get run descent\r\n *\r\n * @param {Run} run run\r\n * @returns {number} descent\r\n */\r\nvar descent = function descent(run) {\r\n  var _run$attributes, _run$attributes$font;\r\n  var fontDescent = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.descent) || 0;\r\n  return scale(run) * fontDescent;\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Get run lineGap\r\n *\r\n * @param {Object} run run\r\n * @returns {number} lineGap\r\n */\r\nvar lineGap = function lineGap(run) {\r\n  var _run$attributes, _run$attributes$font;\r\n  return (((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.lineGap) || 0) * scale(run);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Get run height\r\n *\r\n * @param {Run} run run\r\n * @returns {number} height\r\n */\r\nvar height$1 = function height(run) {\r\n  var _run$attributes;\r\n  var lineHeight = (_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.lineHeight;\r\n  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Returns attributed string height\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} height\r\n */\r\nvar height = function height(attributedString) {\r\n  var reducer = function reducer(acc, run) {\r\n    return Math.max(acc, height$1(run));\r\n  };\r\n  return attributedString.runs.reduce(reducer, 0);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\r\n\r\n/**\r\n * Checks if two rects intersect each other\r\n *\r\n * @param {Rect} a rect A\r\n * @param {Rect} b rect B\r\n * @returns {boolean} whether rects intersect\r\n */\r\nvar intersects = function intersects(a, b) {\r\n  var x = Math.max(a.x, b.x);\r\n  var num1 = Math.min(a.x + a.width, b.x + b.width);\r\n  var y = Math.max(a.y, b.y);\r\n  var num2 = Math.min(a.y + a.height, b.y + b.height);\r\n  return num1 >= x && num2 >= y;\r\n};\r\n\r\nvar _excluded = [\"excludeRects\"];\r\nvar getLineFragment = function getLineFragment(lineRect, excludeRect) {\r\n  if (!intersects(excludeRect, lineRect)) return [lineRect];\r\n  var eStart = excludeRect.x;\r\n  var eEnd = excludeRect.x + excludeRect.width;\r\n  var lStart = lineRect.x;\r\n  var lEnd = lineRect.x + lineRect.width;\r\n  var a = Object.assign({}, lineRect, {\r\n    width: eStart - lStart\r\n  });\r\n  var b = Object.assign({}, lineRect, {\r\n    x: eEnd,\r\n    width: lEnd - eEnd\r\n  });\r\n  return [a, b].filter(function (r) {\r\n    return r.width > 0;\r\n  });\r\n};\r\nvar getLineFragments = function getLineFragments(rect, excludeRects) {\r\n  var fragments = [rect];\r\n  var _loop = function _loop() {\r\n    var excludeRect = excludeRects[i];\r\n    fragments = fragments.reduce(function (acc, fragment) {\r\n      var pieces = getLineFragment(fragment, excludeRect);\r\n      return acc.concat(pieces);\r\n    }, []);\r\n  };\r\n  for (var i = 0; i < excludeRects.length; i += 1) {\r\n    _loop();\r\n  }\r\n  return fragments;\r\n};\r\nvar generateLineRects = function generateLineRects(container, height) {\r\n  var excludeRects = container.excludeRects,\r\n    rect = _objectWithoutPropertiesLoose(container, _excluded);\r\n  if (!excludeRects) return [rect];\r\n  var lineRects = [];\r\n  var maxY = Math.max.apply(Math, excludeRects.map(function (r) {\r\n    return r.y + r.height;\r\n  }));\r\n  var currentRect = rect;\r\n  while (currentRect.y < maxY) {\r\n    var _partition = partition(currentRect, height),\r\n      lineRect = _partition[0],\r\n      rest = _partition[1];\r\n    var lineRectFragments = getLineFragments(lineRect, excludeRects);\r\n    currentRect = rest;\r\n    lineRects.push.apply(lineRects, lineRectFragments);\r\n  }\r\n  return [].concat(lineRects, [currentRect]);\r\n};\r\n\r\nvar ATTACHMENT_CODE$1 = \"\\uFFFC\"; // 65532\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\r\n\r\n/**\r\n * Remove attachment attribute if no char present\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {AttributedString} attributed string\r\n */\r\nvar purgeAttachments = function purgeAttachments(attributedString) {\r\n  var shouldPurge = !attributedString.string.includes(ATTACHMENT_CODE$1);\r\n  if (!shouldPurge) return attributedString;\r\n  var runs = attributedString.runs.map(function (run) {\r\n    return omit('attachment', run);\r\n  });\r\n  return Object.assign({}, attributedString, {\r\n    runs: runs\r\n  });\r\n};\r\n\r\n/**\r\n * Layout paragraphs inside rectangle\r\n *\r\n * @param {Object} rects rect\r\n * @param {Object[]} lines attributed strings\r\n * @param {number} indent\r\n * @returns {Object} layout blocks\r\n */\r\nvar layoutLines = function layoutLines(rects, lines, indent) {\r\n  var rect = rects.shift();\r\n  var currentY = rect.y;\r\n  return lines.map(function (line, i) {\r\n    var _line$runs, _line$runs$;\r\n    var lineIndent = i === 0 ? indent : 0;\r\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\r\n    var height$1 = Math.max(height(line), style.lineHeight);\r\n    if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\r\n      rect = rects.shift();\r\n      currentY = rect.y;\r\n    }\r\n    var newLine = Object.assign({}, line);\r\n    delete newLine.syllables;\r\n    newLine.box = {\r\n      x: rect.x + lineIndent,\r\n      y: currentY,\r\n      width: rect.width - lineIndent,\r\n      height: height$1\r\n    };\r\n    currentY += height$1;\r\n    return purgeAttachments(newLine);\r\n  });\r\n};\r\n\r\n/**\r\n * Performs line breaking and layout\r\n *\r\n * @param {Object} engines engines\r\n * @param {Object} options layout options\r\n */\r\nvar layoutParagraph = function layoutParagraph(engines, options) {\r\n  /**\r\n   * @param {Rect} container rect\r\n   * @param {Object} paragraph attributed string\r\n   * @returns {Object} layout block\r\n   */\r\n  return function (container, paragraph) {\r\n    var _paragraph$runs, _paragraph$runs$, _paragraph$runs$$attr;\r\n    var height$1 = height(paragraph);\r\n    var indent = ((_paragraph$runs = paragraph.runs) === null || _paragraph$runs === void 0 ? void 0 : (_paragraph$runs$ = _paragraph$runs[0]) === null || _paragraph$runs$ === void 0 ? void 0 : (_paragraph$runs$$attr = _paragraph$runs$.attributes) === null || _paragraph$runs$$attr === void 0 ? void 0 : _paragraph$runs$$attr.indent) || 0;\r\n    var rects = generateLineRects(container, height$1);\r\n    var availableWidths = rects.map(function (r) {\r\n      return r.width;\r\n    });\r\n    availableWidths[0] -= indent;\r\n    var lines = engines.linebreaker(options)(paragraph, availableWidths);\r\n    return layoutLines(rects, lines, indent);\r\n  };\r\n};\r\n\r\n/**\r\n * Slice block at given height\r\n *\r\n * @param {number} height height\r\n * @param {Object} block paragraph block\r\n * @returns {number[]} sliced paragraph block\r\n */\r\nvar sliceAtHeight = function sliceAtHeight(height, block) {\r\n  var newBlock = [];\r\n  var counter = 0;\r\n  for (var i = 0; i < block.length; i += 1) {\r\n    var line = block[i];\r\n    counter += line.box.height;\r\n    if (counter < height) {\r\n      newBlock.push(line);\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n  return newBlock;\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\r\n\r\n/**\r\n * Layout paragraphs inside container until it does not\r\n * fit anymore, performing line wrapping in the process.\r\n *\r\n * @param {Object} engines engines\r\n * @param {Object} options layout options\r\n * @param {Rect} container container rect\r\n */\r\nvar typesetter = function typesetter(engines, options, container) {\r\n  /**\r\n   * @param {AttributedString} attributedStrings attributed strings (paragraphs)\r\n   * @returns {Object[]} paragraph blocks\r\n   */\r\n  return function (attributedStrings) {\r\n    var blocks = [];\r\n    var paragraphs = [].concat(attributedStrings);\r\n    var layoutBlock = layoutParagraph(engines, options);\r\n    var maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\r\n    var truncateEllipsis = container.truncateMode === 'ellipsis';\r\n    var linesCount = maxLines;\r\n    var paragraphRect = copy(container);\r\n    var nextParagraph = paragraphs.shift();\r\n    while (linesCount > 0 && nextParagraph) {\r\n      var block = layoutBlock(paragraphRect, nextParagraph);\r\n      var slicedBlock = block.slice(0, linesCount);\r\n      var linesHeight = height$2(slicedBlock);\r\n      var shouldTruncate = truncateEllipsis && block.length !== slicedBlock.length;\r\n      linesCount -= slicedBlock.length;\r\n      if (paragraphRect.height >= linesHeight) {\r\n        blocks.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\r\n        paragraphRect = crop(linesHeight, paragraphRect);\r\n        nextParagraph = paragraphs.shift();\r\n      } else {\r\n        blocks.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\r\n        break;\r\n      }\r\n    }\r\n    return blocks;\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Get attributed string start value\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} start\r\n */\r\nvar start = function start(attributedString) {\r\n  var runs = attributedString.runs;\r\n  return runs.length === 0 ? 0 : runs[0].start;\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Get attributed string end value\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} end\r\n */\r\nvar end = function end(attributedString) {\r\n  var runs = attributedString.runs;\r\n  return runs.length === 0 ? 0 : last(runs).end;\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Get attributed string length\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} end\r\n */\r\nvar length$1 = function length(attributedString) {\r\n  return end(attributedString) - start(attributedString);\r\n};\r\n\r\nvar bidi$2 = bidiFactory();\r\nvar getBidiLevels$1 = function getBidiLevels(runs) {\r\n  return runs.reduce(function (acc, run) {\r\n    var length = run.end - run.start;\r\n    var levels = repeat(run.attributes.bidiLevel, length);\r\n    return acc.concat(levels);\r\n  }, []);\r\n};\r\nvar getReorderedIndices = function getReorderedIndices(string, segments) {\r\n  // Fill an array with indices\r\n  var indices = [];\r\n  for (var i = 0; i < string.length; i += 1) {\r\n    indices[i] = i;\r\n  }\r\n  // Reverse each segment in order\r\n  segments.forEach(function (_ref) {\r\n    var start = _ref[0],\r\n      end = _ref[1];\r\n    var slice = indices.slice(start, end + 1);\r\n    for (var _i = slice.length - 1; _i >= 0; _i -= 1) {\r\n      indices[end - _i] = slice[_i];\r\n    }\r\n  });\r\n  return indices;\r\n};\r\nvar getItemAtIndex = function getItemAtIndex(runs, objectName, index) {\r\n  for (var i = 0; i < runs.length; i += 1) {\r\n    var run = runs[i];\r\n    var updatedIndex = run.glyphIndices[index - run.start];\r\n    if (index >= run.start && index < run.end) {\r\n      return run[objectName][updatedIndex];\r\n    }\r\n  }\r\n  throw new Error(\"index \" + index + \" out of range\");\r\n};\r\nvar reorderLine = function reorderLine(attributedString) {\r\n  var _attributedString$run;\r\n  var levels = getBidiLevels$1(attributedString.runs);\r\n  var direction = (_attributedString$run = attributedString.runs[0]) === null || _attributedString$run === void 0 ? void 0 : _attributedString$run.attributes.direction;\r\n  var level = direction === 'rtl' ? 1 : 0;\r\n  var end = length$1(attributedString) - 1;\r\n  var paragraphs = [{\r\n    start: 0,\r\n    end: end,\r\n    level: level\r\n  }];\r\n  var embeddingLevels = {\r\n    paragraphs: paragraphs,\r\n    levels: levels\r\n  };\r\n  var segments = bidi$2.getReorderSegments(attributedString.string, embeddingLevels);\r\n\r\n  // No need for bidi reordering\r\n  if (segments.length === 0) return attributedString;\r\n  var indices = getReorderedIndices(attributedString.string, segments);\r\n  var updatedString = bidi$2.getReorderedString(attributedString.string, embeddingLevels);\r\n  var updatedRuns = attributedString.runs.map(function (run) {\r\n    var selectedIndices = indices.slice(run.start, run.end);\r\n    var updatedGlyphs = [];\r\n    var updatedPositions = [];\r\n    var addedGlyphs = new Set();\r\n    for (var i = 0; i < selectedIndices.length; i += 1) {\r\n      var index = selectedIndices[i];\r\n      var glyph = getItemAtIndex(attributedString.runs, 'glyphs', index);\r\n      if (addedGlyphs.has(glyph.id)) continue;\r\n      updatedGlyphs.push(glyph);\r\n      updatedPositions.push(getItemAtIndex(attributedString.runs, 'positions', index));\r\n      if (glyph.isLigature) {\r\n        addedGlyphs.add(glyph.id);\r\n      }\r\n    }\r\n    return _extends({}, run, {\r\n      glyphs: updatedGlyphs,\r\n      positions: updatedPositions\r\n    });\r\n  });\r\n  return _extends({}, attributedString, {\r\n    runs: updatedRuns,\r\n    string: updatedString\r\n  });\r\n};\r\nvar reorderParagraph = function reorderParagraph(lines) {\r\n  return lines.map(reorderLine);\r\n};\r\n\r\n/**\r\n * Perform bidi reordering\r\n */\r\nvar bidiReordering = function bidiReordering() {\r\n  /**\r\n   * @param {Object[]} paragraphs line blocks\r\n   * @returns {Object[]} paragraphs\r\n   */\r\n  return function (paragraphs) {\r\n    return paragraphs.map(reorderParagraph);\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n */\r\n\r\nvar DUMMY_CODEPOINT = 123;\r\n\r\n/**\r\n * Resolve string indices based on glyphs code points\r\n *\r\n * @param {Glyph[]} glyphs\r\n * @returns {number[]} glyph indices\r\n */\r\nvar resolve = function resolve(glyphs) {\r\n  if (glyphs === void 0) {\r\n    glyphs = [];\r\n  }\r\n  return glyphs.reduce(function (acc, glyph) {\r\n    var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];\r\n    if (acc.length === 0) return codePoints.map(function () {\r\n      return 0;\r\n    });\r\n    var last = acc[acc.length - 1];\r\n    var next = codePoints.map(function () {\r\n      return last + 1;\r\n    });\r\n    return [].concat(acc, next);\r\n  }, []);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Position} Position\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * @param {Run} run\r\n * @returns {number}\r\n */\r\nvar getCharacterSpacing = function getCharacterSpacing(run) {\r\n  var _run$attributes;\r\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.characterSpacing) || 0;\r\n};\r\n\r\n/**\r\n * Scale run positions\r\n *\r\n * @param {Run} run\r\n * @param {Position[]} positions\r\n * @returns {Position[]} scaled positions\r\n */\r\nvar scalePositions = function scalePositions(run, positions) {\r\n  var runScale = scale(run);\r\n  var characterSpacing = getCharacterSpacing(run);\r\n  return positions.map(function (position, i) {\r\n    var isLast = i === positions.length;\r\n    var xSpacing = isLast ? 0 : characterSpacing;\r\n    return Object.assign({}, position, {\r\n      xAdvance: position.xAdvance * runScale + xSpacing,\r\n      yAdvance: position.yAdvance * runScale,\r\n      xOffset: position.xOffset * runScale,\r\n      yOffset: position.yOffset * runScale\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Create glyph run\r\n *\r\n * @param {string} string string\r\n */\r\nvar layoutRun = function layoutRun(string) {\r\n  /**\r\n   * @param {Run} run run\r\n   * @returns {Run} glyph run\r\n   */\r\n  return function (run) {\r\n    var start = run.start,\r\n      end = run.end,\r\n      _run$attributes2 = run.attributes,\r\n      attributes = _run$attributes2 === void 0 ? {} : _run$attributes2;\r\n    var font = attributes.font;\r\n    if (!font) return _extends({}, run, {\r\n      glyphs: [],\r\n      glyphIndices: [],\r\n      positions: []\r\n    });\r\n    var runString = string.slice(start, end);\r\n\r\n    // passing LTR To force fontkit to not reverse the string\r\n    var glyphRun = font.layout(runString, undefined, undefined, undefined, 'ltr');\r\n    var positions = scalePositions(run, glyphRun.positions);\r\n    var glyphIndices = resolve(glyphRun.glyphs);\r\n    return _extends({}, run, {\r\n      positions: positions,\r\n      glyphIndices: glyphIndices,\r\n      glyphs: glyphRun.glyphs\r\n    });\r\n  };\r\n};\r\n\r\n/**\r\n * Generate glyphs for single attributed string\r\n */\r\nvar generateGlyphs = function generateGlyphs() {\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string with glyphs\r\n   */\r\n  return function (attributedString) {\r\n    var runs = attributedString.runs.map(layoutRun(attributedString.string));\r\n    return Object.assign({}, attributedString, {\r\n      runs: runs\r\n    });\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Resolves yOffset for run\r\n *\r\n * @param {Run} run run\r\n * @returns {Run} run\r\n */\r\nvar resolveRunYOffset = function resolveRunYOffset(run) {\r\n  var _run$attributes, _run$attributes$font, _run$attributes2;\r\n  if (!run.positions) return run;\r\n  var unitsPerEm = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.unitsPerEm) || 0;\r\n  var yOffset = (((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : _run$attributes2.yOffset) || 0) * unitsPerEm;\r\n  var positions = run.positions.map(function (p) {\r\n    return Object.assign({}, p, {\r\n      yOffset: yOffset\r\n    });\r\n  });\r\n  return Object.assign({}, run, {\r\n    positions: positions\r\n  });\r\n};\r\n\r\n/**\r\n * Resolves yOffset for multiple paragraphs\r\n */\r\nvar resolveYOffset = function resolveYOffset() {\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\r\n  return function (attributedString) {\r\n    var runs = attributedString.runs.map(resolveRunYOffset);\r\n    return Object.assign({}, attributedString, {\r\n      runs: runs\r\n    });\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Sort runs in ascending order\r\n *\r\n * @param {Run[]} runs\r\n * @returns {Run[]} sorted runs\r\n */\r\nvar sort = function sort(runs) {\r\n  return runs.sort(function (a, b) {\r\n    return a.start - b.start || a.end - b.end;\r\n  });\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Is run empty (start === end)\r\n *\r\n * @param {Run} run run\r\n * @returns {boolean} is run empty\r\n */\r\nvar isEmpty = function isEmpty(run) {\r\n  return run.start === run.end;\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Point} Point\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Sort points in ascending order\r\n * @param {Point} a first point\r\n * @param {Point} b second point\r\n * @returns {number} sort order\r\n */\r\nvar sortPoints = function sortPoints(a, b) {\r\n  return a[1] - b[1] || a[3] - b[3];\r\n};\r\n\r\n/**\r\n * @param {Run[]} runs\r\n * @returns {Point[]} points\r\n */\r\nvar generatePoints = function generatePoints(runs) {\r\n  var result = runs.reduce(function (acc, run, i) {\r\n    return acc.concat([['start', run.start, run.attributes, i], ['end', run.end, run.attributes, i]]);\r\n  }, []);\r\n  return result.sort(sortPoints);\r\n};\r\n\r\n/**\r\n * @param {Run[]} runs\r\n * @returns {Run} merged runs\r\n */\r\nvar mergeRuns = function mergeRuns(runs) {\r\n  return runs.reduce(function (acc, run) {\r\n    var attributes = Object.assign({}, acc.attributes, run.attributes);\r\n    return Object.assign({}, run, {\r\n      attributes: attributes\r\n    });\r\n  }, {});\r\n};\r\n\r\n/**\r\n * @param {Run[]} runs\r\n * @returns {Run[][]} grouped runs\r\n */\r\nvar groupEmptyRuns = function groupEmptyRuns(runs) {\r\n  var groups = runs.reduce(function (acc, run) {\r\n    if (!acc[run.start]) acc[run.start] = [];\r\n    acc[run.start].push(run);\r\n    return acc;\r\n  }, []);\r\n  return Object.values(groups);\r\n};\r\n\r\n/**\r\n * @param {Run[]} runs\r\n * @returns {Run[]} flattened runs\r\n */\r\nvar flattenEmptyRuns = function flattenEmptyRuns(runs) {\r\n  return groupEmptyRuns(runs).map(mergeRuns);\r\n};\r\n\r\n/**\r\n * @param {Run[]} runs\r\n * @returns {Run[]} flattened runs\r\n */\r\nvar flattenRegularRuns = function flattenRegularRuns(runs) {\r\n  var res = [];\r\n  var points = generatePoints(runs);\r\n  var start = -1;\r\n  var attrs = {};\r\n  var stack = [];\r\n  for (var i = 0; i < points.length; i += 1) {\r\n    var _points$i = points[i],\r\n      type = _points$i[0],\r\n      offset = _points$i[1],\r\n      attributes = _points$i[2];\r\n    if (start !== -1 && start < offset) {\r\n      res.push({\r\n        start: start,\r\n        end: offset,\r\n        attributes: attrs\r\n      });\r\n    }\r\n    if (type === 'start') {\r\n      stack.push(attributes);\r\n      attrs = Object.assign({}, attrs, attributes);\r\n    } else {\r\n      attrs = {};\r\n      for (var j = 0; j < stack.length; j += 1) {\r\n        if (stack[j] === attributes) {\r\n          // eslint-disable-next-line no-plusplus\r\n          stack.splice(j--, 1);\r\n        } else {\r\n          attrs = Object.assign({}, attrs, stack[j]);\r\n        }\r\n      }\r\n    }\r\n    start = offset;\r\n  }\r\n  return res;\r\n};\r\n\r\n/**\r\n * Flatten many runs\r\n *\r\n * @param {Run[]} runs\r\n * @returns {Run[]} flattened runs\r\n */\r\nvar flatten = function flatten(runs) {\r\n  if (runs === void 0) {\r\n    runs = [];\r\n  }\r\n  var emptyRuns = flattenEmptyRuns(runs.filter(function (run) {\r\n    return isEmpty(run);\r\n  }));\r\n  var regularRuns = flattenRegularRuns(runs.filter(function (run) {\r\n    return !isEmpty(run);\r\n  }));\r\n  return sort(emptyRuns.concat(regularRuns));\r\n};\r\n\r\n/**\r\n * Returns empty attributed string\r\n *\r\n * @returns {Object} empty attributed string\r\n */\r\nvar empty = function empty() {\r\n  return {\r\n    string: '',\r\n    runs: []\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n *\r\n * @param {AttributedString} attributedString\r\n * @returns {AttributedString} attributed string without font\r\n */\r\nvar omitFont = function omitFont(attributedString) {\r\n  var runs = attributedString.runs.map(function (run) {\r\n    return omit('font', run);\r\n  });\r\n  return Object.assign({}, attributedString, {\r\n    runs: runs\r\n  });\r\n};\r\n\r\n/**\r\n * Performs font substitution and script itemization on attributed string\r\n *\r\n * @param {Object} engines engines\r\n * @param {Object} options layout options\r\n */\r\nvar preprocessRuns = function preprocessRuns(engines, options) {\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} processed attributed string\r\n   */\r\n  return function (attributedString) {\r\n    if (isNil(attributedString)) return empty();\r\n    var string = attributedString.string;\r\n    var fontSubstitution = engines.fontSubstitution,\r\n      scriptItemizer = engines.scriptItemizer,\r\n      bidi = engines.bidi;\r\n    var _omitFont = omitFont(attributedString),\r\n      omittedFontRuns = _omitFont.runs;\r\n    var _scriptItemizer = scriptItemizer(options)(attributedString),\r\n      itemizationRuns = _scriptItemizer.runs;\r\n    var _fontSubstitution = fontSubstitution(options)(attributedString),\r\n      substitutedRuns = _fontSubstitution.runs;\r\n    var _bidi = bidi(options)(attributedString),\r\n      bidiRuns = _bidi.runs;\r\n    var runs = bidiRuns.concat(substitutedRuns).concat(itemizationRuns).concat(omittedFontRuns);\r\n    return {\r\n      string: string,\r\n      runs: flatten(runs)\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Breaks attributed string into paragraphs\r\n */\r\nvar splitParagraphs = function splitParagraphs() {\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString[]} attributed string array\r\n   */\r\n  return function (attributedString) {\r\n    var res = [];\r\n    var start = 0;\r\n    var breakPoint = attributedString.string.indexOf('\\n') + 1;\r\n    while (breakPoint > 0) {\r\n      res.push(slice(start, breakPoint, attributedString));\r\n      start = breakPoint;\r\n      breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\r\n    }\r\n    if (start === 0) {\r\n      res.push(attributedString);\r\n    } else if (start < attributedString.string.length) {\r\n      res.push(slice(start, length$1(attributedString), attributedString));\r\n    }\r\n    return res;\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Position} Position\r\n */\r\n\r\n/**\r\n * Return positions advance width\r\n *\r\n * @param {Position[]} positions positions\r\n * @returns {number} advance width\r\n */\r\nvar advanceWidth$2 = function advanceWidth(positions) {\r\n  return positions.reduce(function (acc, pos) {\r\n    return acc + (pos.xAdvance || 0);\r\n  }, 0);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Return run advance width\r\n *\r\n * @param {Run} run run\r\n * @returns {number} advance width\r\n */\r\nvar advanceWidth$1 = function advanceWidth(run) {\r\n  return advanceWidth$2(run.positions || []);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Returns attributed string advancewidth\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} advance width\r\n */\r\nvar advanceWidth = function advanceWidth(attributedString) {\r\n  var reducer = function reducer(acc, run) {\r\n    return acc + advanceWidth$1(run);\r\n  };\r\n  return attributedString.runs.reduce(reducer, 0);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n */\r\n\r\nvar WHITE_SPACES_CODE = 32;\r\n\r\n/**\r\n * Check if glyph is white space\r\n *\r\n * @param {Glyph} [glyph] glyph\r\n * @returns {boolean} whether glyph is white space\r\n * */\r\nvar isWhiteSpace = function isWhiteSpace(glyph) {\r\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\r\n  return codePoints.includes(WHITE_SPACES_CODE);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Position} Position\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Get white space leading positions\r\n *\r\n * @param {Run} run run\r\n * @returns {Position[]} white space leading positions\r\n */\r\nvar leadingPositions = function leadingPositions(run) {\r\n  var glyphs = run.glyphs || [];\r\n  var positions = run.positions || [];\r\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\r\n    return !isWhiteSpace(g);\r\n  });\r\n  return positions.slice(0, leadingWhitespaces);\r\n};\r\n\r\n/**\r\n * Get run leading white space offset\r\n *\r\n * @param {Run} run run\r\n * @returns {number} leading white space offset\r\n */\r\nvar leadingOffset$1 = function leadingOffset(run) {\r\n  var positions = leadingPositions(run);\r\n  return positions.reduce(function (acc, pos) {\r\n    return acc + (pos.xAdvance || 0);\r\n  }, 0);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Get attributed string leading white space offset\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} leading white space offset\r\n */\r\nvar leadingOffset = function leadingOffset(attributedString) {\r\n  var runs = attributedString.runs || [];\r\n  return leadingOffset$1(runs[0]);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Position} Position\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * @template T\r\n * @param {T[]} array\r\n * @returns {T[]} reversed array\r\n */\r\nvar reverse = function reverse(array) {\r\n  return [].concat(array).reverse();\r\n};\r\n\r\n/**\r\n * Get white space trailing positions\r\n *\r\n * @param {Run} run run\r\n * @returns {Position[]} white space trailing positions\r\n */\r\nvar trailingPositions = function trailingPositions(run) {\r\n  var glyphs = reverse(run.glyphs || []);\r\n  var positions = reverse(run.positions || []);\r\n  var leadingWhitespaces = glyphs.findIndex(function (g) {\r\n    return !isWhiteSpace(g);\r\n  });\r\n  return positions.slice(0, leadingWhitespaces);\r\n};\r\n\r\n/**\r\n * Get run trailing white space offset\r\n *\r\n * @param {Run} run run\r\n * @returns {number} trailing white space offset\r\n */\r\nvar trailingOffset$1 = function trailingOffset(run) {\r\n  var positions = trailingPositions(run);\r\n  return positions.reduce(function (acc, pos) {\r\n    return acc + (pos.xAdvance || 0);\r\n  }, 0);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Get attributed string trailing white space offset\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} trailing white space offset\r\n */\r\nvar trailingOffset = function trailingOffset(attributedString) {\r\n  var runs = attributedString.runs || [];\r\n  return trailingOffset$1(last(runs));\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Drop last char of run\r\n *\r\n * @param {Run} run run\r\n * @returns {Run} run without last char\r\n */\r\nvar dropLast$1 = function dropLast(run) {\r\n  return slice$1(0, run.end - run.start - 1, run);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Drop last glyph\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {AttributedString} attributed string with new glyph\r\n */\r\nvar dropLast = function dropLast(attributedString) {\r\n  var string = dropLast$2(attributedString.string);\r\n  var runs = adjust(-1, dropLast$1, attributedString.runs);\r\n  return Object.assign({}, attributedString, {\r\n    string: string,\r\n    runs: runs\r\n  });\r\n};\r\n\r\nvar ALIGNMENT_FACTORS = {\r\n  center: 0.5,\r\n  right: 1\r\n};\r\n\r\n/**\r\n * Remove new line char at the end of line if present\r\n *\r\n * @param {Object}  line\r\n * @returns {Object} line\r\n */\r\nvar removeNewLine = function removeNewLine(line) {\r\n  return last(line.string) === '\\n' ? dropLast(line) : line;\r\n};\r\nvar getOverflowLeft = function getOverflowLeft(line) {\r\n  return leadingOffset(line) + (line.overflowLeft || 0);\r\n};\r\nvar getOverflowRight = function getOverflowRight(line) {\r\n  return trailingOffset(line) + (line.overflowRight || 0);\r\n};\r\n\r\n/**\r\n * Ignore whitespace at the start and end of a line for alignment\r\n *\r\n * @param {Object}  line\r\n * @returns {Object} line\r\n */\r\nvar adjustOverflow = function adjustOverflow(line) {\r\n  var overflowLeft = getOverflowLeft(line);\r\n  var overflowRight = getOverflowRight(line);\r\n  var x = line.box.x - overflowLeft;\r\n  var width = line.box.width + overflowLeft + overflowRight;\r\n  var box = Object.assign({}, line.box, {\r\n    x: x,\r\n    width: width\r\n  });\r\n  return Object.assign({}, line, {\r\n    box: box,\r\n    overflowLeft: overflowLeft,\r\n    overflowRight: overflowRight\r\n  });\r\n};\r\n\r\n/**\r\n * Performs line justification by calling appropiate engine\r\n *\r\n * @param {Object} engines engines\r\n * @param {Object} options layout options\r\n * @param {string} align text align\r\n */\r\nvar justifyLine$1 = function justifyLine(engines, options, align) {\r\n  /**\r\n   * @param {Object} line lint\r\n   * @returns {Object} line\r\n   */\r\n  return function (line) {\r\n    var lineWidth = advanceWidth(line);\r\n    var alignFactor = ALIGNMENT_FACTORS[align] || 0;\r\n    var remainingWidth = Math.max(0, line.box.width - lineWidth);\r\n    var shouldJustify = align === 'justify' || lineWidth > line.box.width;\r\n    var x = line.box.x + remainingWidth * alignFactor;\r\n    var box = Object.assign({}, line.box, {\r\n      x: x\r\n    });\r\n    var newLine = Object.assign({}, line, {\r\n      box: box\r\n    });\r\n    return shouldJustify ? engines.justification(options)(newLine) : newLine;\r\n  };\r\n};\r\nvar finalizeLine = function finalizeLine(line) {\r\n  var lineAscent = 0;\r\n  var lineDescent = 0;\r\n  var lineHeight = 0;\r\n  var lineXAdvance = 0;\r\n  var runs = line.runs.map(function (run) {\r\n    var height = height$1(run);\r\n    var ascent = ascent$1(run);\r\n    var descent$1 = descent(run);\r\n    var xAdvance = advanceWidth$1(run);\r\n    lineHeight = Math.max(lineHeight, height);\r\n    lineAscent = Math.max(lineAscent, ascent);\r\n    lineDescent = Math.max(lineDescent, descent$1);\r\n    lineXAdvance += xAdvance;\r\n    return Object.assign({}, run, {\r\n      height: height,\r\n      ascent: ascent,\r\n      descent: descent$1,\r\n      xAdvance: xAdvance\r\n    });\r\n  });\r\n  return Object.assign({}, line, {\r\n    runs: runs,\r\n    height: lineHeight,\r\n    ascent: lineAscent,\r\n    descent: lineDescent,\r\n    xAdvance: lineXAdvance\r\n  });\r\n};\r\n\r\n/**\r\n * Finalize line by performing line justification\r\n * and text decoration (using appropiate engines)\r\n *\r\n * @param {Object} engines engines\r\n * @param {Object} options layout options\r\n */\r\nvar finalizeBlock = function finalizeBlock(engines, options) {\r\n  if (engines === void 0) {\r\n    engines = {};\r\n  }\r\n  /**\r\n   * @param {Object} line lint\r\n   * @param {number} i line index\r\n   * @param {Object[]} lines total lines\r\n   * @returns {Object} line\r\n   */\r\n  return function (line, i, lines) {\r\n    var _line$runs, _line$runs$;\r\n    var isLastFragment = i === lines.length - 1;\r\n    var style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\r\n    var align = isLastFragment ? style.alignLastLine : style.align;\r\n    return compose(finalizeLine, engines.textDecoration(options), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\r\n  };\r\n};\r\n\r\n/**\r\n * Finalize line block by performing line justification\r\n * and text decoration (using appropiate engines)\r\n *\r\n * @param {Object} engines engines\r\n * @param {Object} options layout options\r\n */\r\nvar finalizeFragments = function finalizeFragments(engines, options) {\r\n  /**\r\n   * @param {Object[]} blocks line blocks\r\n   * @returns {Object[]} blocks\r\n   */\r\n  return function (blocks) {\r\n    var blockFinalizer = finalizeBlock(engines, options);\r\n    return blocks.map(function (block) {\r\n      return block.map(blockFinalizer);\r\n    });\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\nvar ATTACHMENT_CODE = 0xfffc; // 65532\r\n\r\nvar isReplaceGlyph = function isReplaceGlyph(glyph) {\r\n  return glyph.codePoints.includes(ATTACHMENT_CODE);\r\n};\r\n\r\n/**\r\n * Resolve attachments of run\r\n *\r\n * @param {Object}  run\r\n * @returns {Object} run\r\n */\r\nvar resolveRunAttachments = function resolveRunAttachments(run) {\r\n  var _run$attributes;\r\n  if (!run.positions) return run;\r\n  var glyphs = run.glyphs || [];\r\n  var attachment = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.attachment) || {};\r\n  var positions = run.positions.map(function (position, i) {\r\n    var glyph = glyphs[i];\r\n    if (attachment && attachment.width && isReplaceGlyph(glyph)) {\r\n      return Object.assign({}, position, {\r\n        xAdvance: attachment.width\r\n      });\r\n    }\r\n    return Object.assign({}, position);\r\n  });\r\n  return Object.assign({}, run, {\r\n    positions: positions\r\n  });\r\n};\r\n\r\n/**\r\n * Resolve attachments for multiple paragraphs\r\n */\r\nvar resolveAttachments = function resolveAttachments() {\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\r\n  return function (attributedString) {\r\n    var runs = attributedString.runs.map(resolveRunAttachments);\r\n    return Object.assign({}, attributedString, {\r\n      runs: runs\r\n    });\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Attributes} Attributes\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * @param {Attributes} a attributes\r\n * @returns {Attributes} attributes with defaults\r\n */\r\nvar applyAttributes = function applyAttributes(a) {\r\n  return {\r\n    align: a.align || (a.direction === 'rtl' ? 'right' : 'left'),\r\n    alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\r\n    attachment: a.attachment || null,\r\n    backgroundColor: a.backgroundColor || null,\r\n    bullet: a.bullet || null,\r\n    characterSpacing: a.characterSpacing || 0,\r\n    color: a.color || 'black',\r\n    direction: a.direction || 'ltr',\r\n    features: a.features || [],\r\n    fill: a.fill !== false,\r\n    font: a.font || null,\r\n    fontSize: a.fontSize || 12,\r\n    hangingPunctuation: a.hangingPunctuation || false,\r\n    hyphenationFactor: a.hyphenationFactor || 0,\r\n    indent: a.indent || 0,\r\n    justificationFactor: a.justificationFactor || 1,\r\n    lineHeight: a.lineHeight || null,\r\n    lineSpacing: a.lineSpacing || 0,\r\n    link: a.link || null,\r\n    marginLeft: a.marginLeft || a.margin || 0,\r\n    marginRight: a.marginRight || a.margin || 0,\r\n    opacity: a.opacity,\r\n    paddingTop: a.paddingTop || a.padding || 0,\r\n    paragraphSpacing: a.paragraphSpacing || 0,\r\n    script: a.script || null,\r\n    shrinkFactor: a.shrinkFactor || 0,\r\n    strike: a.strike || false,\r\n    strikeColor: a.strikeColor || a.color || 'black',\r\n    strikeStyle: a.strikeStyle || 'solid',\r\n    stroke: a.stroke || false,\r\n    underline: a.underline || false,\r\n    underlineColor: a.underlineColor || a.color || 'black',\r\n    underlineStyle: a.underlineStyle || 'solid',\r\n    verticalAlign: a.verticalAlign || null,\r\n    wordSpacing: a.wordSpacing || 0,\r\n    yOffset: a.yOffset || 0\r\n  };\r\n};\r\n\r\n/**\r\n * Apply default style to run\r\n *\r\n * @param {Run} run run\r\n * @returns {Run} run with styles\r\n */\r\nvar applyRunStyles = function applyRunStyles(run) {\r\n  var attributes = applyAttributes(run.attributes);\r\n  return Object.assign({}, run, {\r\n    attributes: attributes\r\n  });\r\n};\r\n\r\n/**\r\n * Apply default attributes for an attributed string\r\n */\r\nvar applyDefaultStyles = function applyDefaultStyles() {\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\r\n  return function (attributedString) {\r\n    var string = attributedString.string || '';\r\n    var runs = (attributedString.runs || []).map(applyRunStyles);\r\n    return {\r\n      string: string,\r\n      runs: runs\r\n    };\r\n  };\r\n};\r\n\r\n/* eslint-disable no-restricted-syntax */\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\r\n */\r\nvar verticalAlignment = function verticalAlignment() {\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\r\n  return function (attributedString) {\r\n    attributedString.runs.forEach(function (run) {\r\n      var attributes = run.attributes;\r\n      var verticalAlign = attributes.verticalAlign;\r\n      if (verticalAlign === 'sub') {\r\n        attributes.yOffset = -0.2;\r\n      } else if (verticalAlign === 'super') {\r\n        attributes.yOffset = 0.4;\r\n      }\r\n    });\r\n    return attributedString;\r\n  };\r\n};\r\n\r\nvar bidi$1 = bidiFactory();\r\nvar getBidiLevels = function getBidiLevels(runs) {\r\n  return runs.reduce(function (acc, run) {\r\n    var length = run.end - run.start;\r\n    var levels = repeat(run.attributes.bidiLevel, length);\r\n    return acc.concat(levels);\r\n  }, []);\r\n};\r\n\r\n/**\r\n * Perform bidi mirroring\r\n */\r\nvar mirrorString = function mirrorString() {\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\r\n  return function (attributedString) {\r\n    var levels = getBidiLevels(attributedString.runs);\r\n    var updatedString = '';\r\n    attributedString.string.split('').forEach(function (char, index) {\r\n      var isRTL = levels[index] % 2 === 1;\r\n      var mirroredChar = isRTL ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index)) : null;\r\n      updatedString += mirroredChar || char;\r\n    });\r\n    return _extends({}, attributedString, {\r\n      string: updatedString,\r\n      levels: levels\r\n    });\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Rect} Rect\r\n */\r\n\r\n/**\r\n * A LayoutEngine is the main object that performs text layout.\r\n * It accepts an AttributedString and a Container object\r\n * to layout text into, and uses several helper objects to perform\r\n * various layout tasks. These objects can be overridden to customize\r\n * layout behavior.\r\n *\r\n * @param {Object} engines engines\r\n */\r\nvar layoutEngine = function layoutEngine(engines) {\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @param {Rect} container container rect\r\n   * @param {Object} options layout options\r\n   * @returns {Object[]} paragraph blocks\r\n   */\r\n  return function (attributedString, container, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n    var processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines, options), generateGlyphs(), mirrorString(), preprocessRuns(engines, options));\r\n    var processParagraphs = function processParagraphs(paragraphs) {\r\n      return paragraphs.map(processParagraph);\r\n    };\r\n    return compose(finalizeFragments(engines, options), bidiReordering(), typesetter(engines, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);\r\n  };\r\n};\r\n\r\nvar bidi = bidiFactory();\r\n\r\n/**\r\n * @param  {Object}  layout options\r\n * @param  {Object}  attributed string\r\n * @return {Object} attributed string\r\n */\r\nvar bidiEngine = function bidiEngine() {\r\n  return function (attributedString) {\r\n    var _attributedString$run;\r\n    var string = attributedString.string;\r\n    var direction = (_attributedString$run = attributedString.runs[0]) === null || _attributedString$run === void 0 ? void 0 : _attributedString$run.attributes.direction;\r\n    var _bidi$getEmbeddingLev = bidi.getEmbeddingLevels(string, direction),\r\n      levels = _bidi$getEmbeddingLev.levels;\r\n    var lastLevel = null;\r\n    var lastIndex = 0;\r\n    var index = 0;\r\n    var res = [];\r\n    for (var i = 0; i < levels.length; i += 1) {\r\n      var level = levels[i];\r\n      if (level !== lastLevel) {\r\n        if (lastLevel !== null) {\r\n          res.push({\r\n            start: lastIndex,\r\n            end: index,\r\n            attributes: {\r\n              bidiLevel: lastLevel\r\n            }\r\n          });\r\n        }\r\n        lastIndex = index;\r\n        lastLevel = level;\r\n      }\r\n      index += 1;\r\n    }\r\n    if (lastIndex < string.length) {\r\n      res.push({\r\n        start: lastIndex,\r\n        end: string.length,\r\n        attributes: {\r\n          bidiLevel: lastLevel\r\n        }\r\n      });\r\n    }\r\n    return {\r\n      string: string,\r\n      runs: res\r\n    };\r\n  };\r\n};\r\n\r\n/* eslint-disable no-plusplus */\r\nvar INFINITY = 10000;\r\n\r\n/**\r\n * @param {Object[]} subnodes\r\n * @param {number[]} widths\r\n * @param {number} lineNumber\r\n * @returns {number}\r\n */\r\nvar getNextBreakpoint = function getNextBreakpoint(subnodes, widths, lineNumber) {\r\n  var position = null;\r\n  var minimumBadness = Infinity;\r\n  var sum = {\r\n    width: 0,\r\n    stretch: 0,\r\n    shrink: 0\r\n  };\r\n  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];\r\n  var calculateRatio = function calculateRatio(node) {\r\n    if (sum.width < lineLength) {\r\n      return sum.stretch - node.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\r\n    }\r\n    if (sum.width > lineLength) {\r\n      return sum.shrink - node.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\r\n    }\r\n    return 0;\r\n  };\r\n  for (var i = 0; i < subnodes.length; i += 1) {\r\n    var node = subnodes[i];\r\n    if (node.type === 'box') {\r\n      sum.width += node.width;\r\n    } else if (node.type === 'glue') {\r\n      sum.width += node.width;\r\n      sum.stretch += node.stretch;\r\n      sum.shrink += node.shrink;\r\n    }\r\n    if (sum.width - sum.shrink > lineLength) {\r\n      if (position === null) {\r\n        var j = i === 0 ? i + 1 : i;\r\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\r\n          j++;\r\n        }\r\n        position = j - 1;\r\n      }\r\n      break;\r\n    }\r\n    if (node.type === 'penalty' || node.type === 'glue') {\r\n      var ratio = calculateRatio(node);\r\n      var penalty = node.type === 'penalty' ? node.penalty : 0;\r\n      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;\r\n      if (minimumBadness >= badness) {\r\n        position = i;\r\n        minimumBadness = badness;\r\n      }\r\n    }\r\n  }\r\n  return sum.width - sum.shrink > lineLength ? position : null;\r\n};\r\n\r\n/**\r\n * @param {Object[]} nodes\r\n * @param {number[]} widths\r\n */\r\nvar applyBestFit = function applyBestFit(nodes, widths) {\r\n  var count = 0;\r\n  var lineNumber = 0;\r\n  var subnodes = nodes;\r\n  var breakpoints = [{\r\n    position: 0\r\n  }];\r\n  while (subnodes.length > 0) {\r\n    var breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\r\n    if (breakpoint !== null) {\r\n      count += breakpoint;\r\n      breakpoints.push({\r\n        position: count\r\n      });\r\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\r\n      count++;\r\n      lineNumber++;\r\n    } else {\r\n      subnodes = [];\r\n    }\r\n  }\r\n  return breakpoints;\r\n};\r\n\r\n/* eslint-disable no-param-reassign */\r\n/* eslint-disable max-classes-per-file */\r\nvar Node = /*#__PURE__*/function () {\r\n  function Node(data) {\r\n    this.prev = null;\r\n    this.next = null;\r\n    this.data = data;\r\n  }\r\n  var _proto = Node.prototype;\r\n  _proto.toString = function toString() {\r\n    return this.data.toString();\r\n  };\r\n  return Node;\r\n}();\r\nvar LinkedList = /*#__PURE__*/function () {\r\n  function LinkedList() {\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.listSize = 0;\r\n    this.listLength = 0;\r\n  }\r\n  var _proto2 = LinkedList.prototype;\r\n  _proto2.isLinked = function isLinked(node) {\r\n    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());\r\n  };\r\n  _proto2.size = function size() {\r\n    return this.listSize;\r\n  };\r\n  _proto2.isEmpty = function isEmpty() {\r\n    return this.listSize === 0;\r\n  };\r\n  _proto2.first = function first() {\r\n    return this.head;\r\n  };\r\n  _proto2.last = function last() {\r\n    return this.last;\r\n  };\r\n  _proto2.toString = function toString() {\r\n    return this.toArray().toString();\r\n  };\r\n  _proto2.toArray = function toArray() {\r\n    var node = this.head;\r\n    var result = [];\r\n    while (node !== null) {\r\n      result.push(node);\r\n      node = node.next;\r\n    }\r\n    return result;\r\n  };\r\n  _proto2.forEach = function forEach(fun) {\r\n    var node = this.head;\r\n    while (node !== null) {\r\n      fun(node);\r\n      node = node.next;\r\n    }\r\n  };\r\n  _proto2.contains = function contains(n) {\r\n    var node = this.head;\r\n    if (!this.isLinked(n)) {\r\n      return false;\r\n    }\r\n    while (node !== null) {\r\n      if (node === n) {\r\n        return true;\r\n      }\r\n      node = node.next;\r\n    }\r\n    return false;\r\n  };\r\n  _proto2.at = function at(i) {\r\n    var node = this.head;\r\n    var index = 0;\r\n    if (i >= this.listLength || i < 0) {\r\n      return null;\r\n    }\r\n    while (node !== null) {\r\n      if (i === index) {\r\n        return node;\r\n      }\r\n      node = node.next;\r\n      index += 1;\r\n    }\r\n    return null;\r\n  };\r\n  _proto2.insertAfter = function insertAfter(node, newNode) {\r\n    if (!this.isLinked(node)) {\r\n      return this;\r\n    }\r\n    newNode.prev = node;\r\n    newNode.next = node.next;\r\n    if (node.next === null) {\r\n      this.tail = newNode;\r\n    } else {\r\n      node.next.prev = newNode;\r\n    }\r\n    node.next = newNode;\r\n    this.listSize += 1;\r\n    return this;\r\n  };\r\n  _proto2.insertBefore = function insertBefore(node, newNode) {\r\n    if (!this.isLinked(node)) {\r\n      return this;\r\n    }\r\n    newNode.prev = node.prev;\r\n    newNode.next = node;\r\n    if (node.prev === null) {\r\n      this.head = newNode;\r\n    } else {\r\n      node.prev.next = newNode;\r\n    }\r\n    node.prev = newNode;\r\n    this.listSize += 1;\r\n    return this;\r\n  };\r\n  _proto2.push = function push(node) {\r\n    if (this.head === null) {\r\n      this.unshift(node);\r\n    } else {\r\n      this.insertAfter(this.tail, node);\r\n    }\r\n    return this;\r\n  };\r\n  _proto2.unshift = function unshift(node) {\r\n    if (this.head === null) {\r\n      this.head = node;\r\n      this.tail = node;\r\n      node.prev = null;\r\n      node.next = null;\r\n      this.listSize += 1;\r\n    } else {\r\n      this.insertBefore(this.head, node);\r\n    }\r\n    return this;\r\n  };\r\n  _proto2.remove = function remove(node) {\r\n    if (!this.isLinked(node)) {\r\n      return this;\r\n    }\r\n    if (node.prev === null) {\r\n      this.head = node.next;\r\n    } else {\r\n      node.prev.next = node.next;\r\n    }\r\n    if (node.next === null) {\r\n      this.tail = node.prev;\r\n    } else {\r\n      node.next.prev = node.prev;\r\n    }\r\n    this.listSize -= 1;\r\n    return this;\r\n  };\r\n  _proto2.pop = function pop() {\r\n    var node = this.tail;\r\n    this.tail.prev.next = null;\r\n    this.tail = this.tail.prev;\r\n    this.listSize -= 1;\r\n    node.prev = null;\r\n    node.next = null;\r\n    return node;\r\n  };\r\n  _proto2.shift = function shift() {\r\n    var node = this.head;\r\n    this.head.next.prev = null;\r\n    this.head = this.head.next;\r\n    this.listSize -= 1;\r\n    node.prev = null;\r\n    node.next = null;\r\n    return node;\r\n  };\r\n  return LinkedList;\r\n}();\r\nLinkedList.Node = Node;\r\n\r\n/* eslint-disable no-restricted-properties */\r\n\r\n/**\r\n * @param {Object[]} nodes\r\n * @param {number[]} lines\r\n * @param {Object} settings\r\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\r\n *\r\n * Licensed under the new BSD License.\r\n * Copyright 2009-2010, Bram Stein\r\n * All rights reserved.\r\n */\r\nvar linebreak = function linebreak(nodes, lines, settings) {\r\n  var options = {\r\n    demerits: {\r\n      line: settings && settings.demerits && settings.demerits.line || 10,\r\n      flagged: settings && settings.demerits && settings.demerits.flagged || 100,\r\n      fitness: settings && settings.demerits && settings.demerits.fitness || 3000\r\n    },\r\n    tolerance: settings && settings.tolerance || 3\r\n  };\r\n  var activeNodes = new LinkedList();\r\n  var sum = {\r\n    width: 0,\r\n    stretch: 0,\r\n    shrink: 0\r\n  };\r\n  var lineLengths = lines;\r\n  var breaks = [];\r\n  var tmp = {\r\n    data: {\r\n      demerits: Infinity\r\n    }\r\n  };\r\n  function breakpoint(position, demerits, ratio, line, fitnessClass, totals, previous) {\r\n    return {\r\n      position: position,\r\n      demerits: demerits,\r\n      ratio: ratio,\r\n      line: line,\r\n      fitnessClass: fitnessClass,\r\n      totals: totals || {\r\n        width: 0,\r\n        stretch: 0,\r\n        shrink: 0\r\n      },\r\n      previous: previous\r\n    };\r\n  }\r\n  function computeCost(start, end, active, currentLine) {\r\n    var width = sum.width - active.totals.width;\r\n    var stretch = 0;\r\n    var shrink = 0;\r\n    // If the current line index is within the list of linelengths, use it, otherwise use\r\n    // the last line length of the list.\r\n    var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\r\n    if (nodes[end].type === 'penalty') {\r\n      width += nodes[end].width;\r\n    }\r\n    if (width < lineLength) {\r\n      // Calculate the stretch ratio\r\n      stretch = sum.stretch - active.totals.stretch;\r\n      if (stretch > 0) {\r\n        return (lineLength - width) / stretch;\r\n      }\r\n      return linebreak.infinity;\r\n    }\r\n    if (width > lineLength) {\r\n      // Calculate the shrink ratio\r\n      shrink = sum.shrink - active.totals.shrink;\r\n      if (shrink > 0) {\r\n        return (lineLength - width) / shrink;\r\n      }\r\n      return linebreak.infinity;\r\n    }\r\n\r\n    // perfect match\r\n    return 0;\r\n  }\r\n\r\n  // Add width, stretch and shrink values from the current\r\n  // break point up to the next box or forced penalty.\r\n  function computeSum(breakPointIndex) {\r\n    var result = {\r\n      width: sum.width,\r\n      stretch: sum.stretch,\r\n      shrink: sum.shrink\r\n    };\r\n    for (var i = breakPointIndex; i < nodes.length; i += 1) {\r\n      if (nodes[i].type === 'glue') {\r\n        result.width += nodes[i].width;\r\n        result.stretch += nodes[i].stretch;\r\n        result.shrink += nodes[i].shrink;\r\n      } else if (nodes[i].type === 'box' || nodes[i].type === 'penalty' && nodes[i].penalty === -linebreak.infinity && i > breakPointIndex) {\r\n        break;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // The main loop of the algorithm\r\n  // eslint-disable-next-line no-shadow\r\n  function mainLoop(node, index, nodes) {\r\n    var active = activeNodes.first();\r\n    var next = null;\r\n    var ratio = 0;\r\n    var demerits = 0;\r\n    /**\r\n     * @type {Object[]}\r\n     */\r\n    var candidates = [];\r\n    var badness;\r\n    var currentLine = 0;\r\n    var tmpSum;\r\n    var currentClass = 0;\r\n    var fitnessClass;\r\n    /**\r\n     * @type {Object}\r\n     */\r\n    var candidate;\r\n    var newNode;\r\n\r\n    // The inner loop iterates through all the active nodes with line < currentLine and then\r\n    // breaks out to insert the new active node candidates before looking at the next active\r\n    // nodes for the next lines. The result of this is that the active node list is always\r\n    // sorted by line number.\r\n    while (active !== null) {\r\n      candidates = [{\r\n        demerits: Infinity\r\n      }, {\r\n        demerits: Infinity\r\n      }, {\r\n        demerits: Infinity\r\n      }, {\r\n        demerits: Infinity\r\n      }];\r\n\r\n      // Iterate through the linked list of active nodes to find new potential active nodes\r\n      // and deactivate current active nodes.\r\n      while (active !== null) {\r\n        next = active.next;\r\n        currentLine = active.data.line + 1;\r\n        ratio = computeCost(active.data.position, index, active.data, currentLine);\r\n\r\n        // Deactive nodes when the distance between the current active node and the\r\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\r\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\r\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\r\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\r\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\r\n          activeNodes.remove(active);\r\n        }\r\n\r\n        // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\r\n        // total demerits and record a candidate active node.\r\n        if (ratio >= -1 && ratio <= options.tolerance) {\r\n          badness = 100 * Math.pow(Math.abs(ratio), 3);\r\n\r\n          // Positive penalty\r\n          if (node.type === 'penalty' && node.penalty >= 0) {\r\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2);\r\n            // Negative penalty but not a forced break\r\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\r\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2);\r\n            // All other cases\r\n          } else {\r\n            demerits = Math.pow(options.demerits.line + badness, 2);\r\n          }\r\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\r\n            demerits += options.demerits.flagged * node.flagged * nodes[active.data.position].flagged;\r\n          }\r\n\r\n          // Calculate the fitness class for this candidate active node.\r\n          if (ratio < -0.5) {\r\n            currentClass = 0;\r\n          } else if (ratio <= 0.5) {\r\n            currentClass = 1;\r\n          } else if (ratio <= 1) {\r\n            currentClass = 2;\r\n          } else {\r\n            currentClass = 3;\r\n          }\r\n\r\n          // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines\r\n          // differ too much.\r\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\r\n            demerits += options.demerits.fitness;\r\n          }\r\n\r\n          // Add the total demerits of the active node to get the total demerits of this candidate node.\r\n          demerits += active.data.demerits;\r\n\r\n          // Only store the best candidate for each fitness class\r\n          if (demerits < candidates[currentClass].demerits) {\r\n            candidates[currentClass] = {\r\n              active: active,\r\n              demerits: demerits,\r\n              ratio: ratio\r\n            };\r\n          }\r\n        }\r\n        active = next;\r\n\r\n        // Stop iterating through active nodes to insert new candidate active nodes in the active list\r\n        // before moving on to the active nodes for the next line.\r\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\r\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\r\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\r\n        // list sorted has a higher priority.\r\n        if (active !== null && active.data.line >= currentLine) {\r\n          break;\r\n        }\r\n      }\r\n      tmpSum = computeSum(index);\r\n      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\r\n        candidate = candidates[fitnessClass];\r\n        if (candidate.demerits < Infinity) {\r\n          newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\r\n          if (active !== null) {\r\n            activeNodes.insertBefore(active, newNode);\r\n          } else {\r\n            activeNodes.push(newNode);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add an active node for the start of the paragraph.\r\n  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, 0, undefined, null)));\r\n\r\n  // eslint-disable-next-line no-shadow\r\n  nodes.forEach(function (node, index, nodes) {\r\n    if (node.type === 'box') {\r\n      sum.width += node.width;\r\n    } else if (node.type === 'glue') {\r\n      if (index > 0 && nodes[index - 1].type === 'box') {\r\n        mainLoop(node, index, nodes);\r\n      }\r\n      sum.width += node.width;\r\n      sum.stretch += node.stretch;\r\n      sum.shrink += node.shrink;\r\n    } else if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\r\n      mainLoop(node, index, nodes);\r\n    }\r\n  });\r\n  if (activeNodes.size() !== 0) {\r\n    // Find the best active node (the one with the least total demerits.)\r\n    activeNodes.forEach(function (node) {\r\n      if (node.data.demerits < tmp.data.demerits) {\r\n        tmp = node;\r\n      }\r\n    });\r\n    while (tmp !== null) {\r\n      breaks.push({\r\n        position: tmp.data.position,\r\n        ratio: tmp.data.ratio\r\n      });\r\n      tmp = tmp.data.previous;\r\n    }\r\n    return breaks.reverse();\r\n  }\r\n  return [];\r\n};\r\nlinebreak.infinity = 10000;\r\nlinebreak.glue = function (width, value, stretch, shrink) {\r\n  return {\r\n    type: 'glue',\r\n    value: value,\r\n    width: width,\r\n    stretch: stretch,\r\n    shrink: shrink\r\n  };\r\n};\r\nlinebreak.box = function (width, value, hyphenated) {\r\n  if (hyphenated === void 0) {\r\n    hyphenated = false;\r\n  }\r\n  return {\r\n    type: 'box',\r\n    width: width,\r\n    value: value,\r\n    hyphenated: hyphenated\r\n  };\r\n};\r\nlinebreak.penalty = function (width, penalty, flagged) {\r\n  return {\r\n    type: 'penalty',\r\n    width: width,\r\n    penalty: penalty,\r\n    flagged: flagged\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Add scalar to run\r\n *\r\n * @param {number} n scalar\r\n * @param {Run} run run\r\n * @returns {Run} added run\r\n */\r\nvar add = function add(n, run) {\r\n  var start = run.start + n;\r\n  var end = run.end + n;\r\n  return Object.assign({}, run, {\r\n    start: start,\r\n    end: end\r\n  });\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Get run length\r\n *\r\n * @param {Run} run run\r\n * @returns {number} length\r\n */\r\nvar length = function length(run) {\r\n  return run.end - run.start;\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Concats two runs into one\r\n *\r\n * @param {Run} runA first run\r\n * @param {Run} runB second run\r\n * @returns {Run} concatenated run\r\n */\r\nvar concat = function concat(runA, runB) {\r\n  var end = runA.end + length(runB);\r\n  var glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\r\n  var positions = (runA.positions || []).concat(runB.positions || []);\r\n  var attributes = Object.assign({}, runA.attributes, runB.attributes);\r\n  var runAIndices = runA.glyphIndices || [];\r\n  var runALastIndex = last(runAIndices) || 0;\r\n  var runBIndices = (runB.glyphIndices || []).map(function (i) {\r\n    return i + runALastIndex + 1;\r\n  });\r\n  var glyphIndices = normalize(runAIndices.concat(runBIndices));\r\n  return Object.assign({}, runA, {\r\n    end: end,\r\n    glyphs: glyphs,\r\n    positions: positions,\r\n    attributes: attributes,\r\n    glyphIndices: glyphIndices\r\n  });\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Insert glyph to run in the given index\r\n *\r\n * @param {number} index index\r\n * @param {Glyph} glyph glyph\r\n * @param {Run} run run\r\n * @returns {Run} run with glyph\r\n */\r\nvar insertGlyph$1 = function insertGlyph(index, glyph, run) {\r\n  if (!glyph) return run;\r\n\r\n  // Split resolves ligature splitting in case new glyph breaks some\r\n  var leadingRun = slice$1(0, index, run);\r\n  var trailingRun = slice$1(index, Infinity, run);\r\n  return concat(append$1(glyph, leadingRun), trailingRun);\r\n};\r\n\r\n/**\r\n * Insert either glyph or code point to run in the given index\r\n *\r\n * @param {number} index index\r\n * @param {Glyph | number} value glyph or codePoint\r\n * @param {Run} run run\r\n * @returns {Run} run with glyph\r\n */\r\nvar insert = function insert(index, value, run) {\r\n  var font = getFont(run);\r\n  var glyph = isNumber(value) ? fromCodePoint(value, font) : value;\r\n  return insertGlyph$1(index, glyph, run);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Get run index at char index\r\n *\r\n * @param {number} n char index\r\n * @param {AttributedString} string attributed string\r\n * @returns {number} run index\r\n */\r\nvar runIndexAt = function runIndexAt(n, string) {\r\n  return runIndexAt$1(n, string.runs);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n * @typedef {import('../types.js').Glyph} Glyph\r\n */\r\n\r\n/**\r\n * Insert glyph into attributed string\r\n *\r\n * @param {number} index index\r\n * @param {Glyph} glyph glyph\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {AttributedString} attributed string with new glyph\r\n */\r\nvar insertGlyph = function insertGlyph(index, glyph, attributedString) {\r\n  var runIndex = runIndexAt(index, attributedString);\r\n\r\n  // Add glyph to the end if run index invalid\r\n  if (runIndex === -1) return append(glyph, attributedString);\r\n  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\r\n  var string = attributedString.string.slice(0, index) + stringFromCodePoints(codePoints) + attributedString.string.slice(index);\r\n  var runs = attributedString.runs.map(function (run, i) {\r\n    if (i === runIndex) return insert(index - run.start, glyph, run);\r\n    if (i > runIndex) return add(codePoints.length, run);\r\n    return run;\r\n  });\r\n  return Object.assign({}, attributedString, {\r\n    string: string,\r\n    runs: runs\r\n  });\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * Advance width between two string indices\r\n *\r\n * @param {number} start glyph index\r\n * @param {number} end glyph index\r\n * @param {Run} run run\r\n * @returns {number} advanced width run\r\n */\r\nvar advanceWidthBetween$1 = function advanceWidthBetween(start, end, run) {\r\n  var runStart = run.start || 0;\r\n  var glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\r\n  var glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\r\n  var positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\r\n  return advanceWidth$2(positions);\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Advance width between start and end\r\n * Does not consider ligature splitting for the moment.\r\n * Check performance impact on supporting this\r\n *\r\n * @param {number} start offset\r\n * @param {number} end offset\r\n * @param {AttributedString} attributedString\r\n * @returns {number} advance width\r\n */\r\nvar advanceWidthBetween = function advanceWidthBetween(start, end, attributedString) {\r\n  var runs = filter(start, end, attributedString.runs);\r\n  return runs.reduce(function (acc, run) {\r\n    return acc + advanceWidthBetween$1(start, end, run);\r\n  }, 0);\r\n};\r\n\r\n/**\r\n * @typedef {import('../../types.js').AttributedString} AttributedString\r\n * @typedef {import('../../types.js').Attributes} Attributes\r\n */\r\n\r\nvar HYPHEN = 0x002d;\r\nvar TOLERANCE_STEPS = 5;\r\nvar TOLERANCE_LIMIT = 50;\r\nvar opts = {\r\n  width: 3,\r\n  stretch: 6,\r\n  shrink: 9\r\n};\r\n\r\n/**\r\n * Slice attributed string to many lines\r\n *\r\n * @param {AttributedString} string attributed string\r\n * @param {Object[]} nodes\r\n * @param {Object[]} breaks\r\n * @returns {AttributedString[]} attributed strings\r\n */\r\nvar breakLines = function breakLines(string, nodes, breaks) {\r\n  var start = 0;\r\n  var end = null;\r\n  var lines = breaks.reduce(function (acc, breakPoint) {\r\n    var node = nodes[breakPoint.position];\r\n    var prevNode = nodes[breakPoint.position - 1];\r\n\r\n    // Last breakpoint corresponds to K&P mandatory final glue\r\n    if (breakPoint.position === nodes.length - 1) return acc;\r\n    var line;\r\n    if (node.type === 'penalty') {\r\n      end = prevNode.value.end;\r\n      line = slice(start, end, string);\r\n      line = insertGlyph(line.length, HYPHEN, line);\r\n    } else {\r\n      end = node.value.end;\r\n      line = slice(start, end, string);\r\n    }\r\n    start = end;\r\n    return [].concat(acc, [line]);\r\n  }, []);\r\n\r\n  // Last line\r\n  lines.push(slice(start, string.string.length, string));\r\n  return lines;\r\n};\r\n\r\n/**\r\n * Return Knuth & Plass nodes based on line and previously calculated syllables\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @param {Object} args attributed string args\r\n * @param {Object} options layout options\r\n * @returns {Object[]} attributed strings\r\n */\r\nvar getNodes = function getNodes(attributedString, _ref, options) {\r\n  var align = _ref.align;\r\n  var start = 0;\r\n  var hyphenWidth = 5;\r\n  var syllables = attributedString.syllables;\r\n  var hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\r\n  var result = syllables.reduce(function (acc, s, index) {\r\n    var width = advanceWidthBetween(start, start + s.length, attributedString);\r\n    if (s.trim() === '') {\r\n      var stretch = width * opts.width / opts.stretch;\r\n      var shrink = width * opts.width / opts.shrink;\r\n      var value = {\r\n        start: start,\r\n        end: start + s.length\r\n      };\r\n      acc.push(linebreak.glue(width, value, stretch, shrink));\r\n    } else {\r\n      var hyphenated = syllables[index + 1] !== ' ';\r\n      var _value = {\r\n        start: start,\r\n        end: start + s.length\r\n      };\r\n      acc.push(linebreak.box(width, _value, hyphenated));\r\n      if (syllables[index + 1] && hyphenated) {\r\n        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\r\n      }\r\n    }\r\n    start += s.length;\r\n    return acc;\r\n  }, []);\r\n  result.push(linebreak.glue(0, null, linebreak.infinity, 0));\r\n  result.push(linebreak.penalty(0, -linebreak.infinity, 1));\r\n  return result;\r\n};\r\n\r\n/**\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {Attributes} styles\r\n */\r\nvar getStyles = function getStyles(attributedString) {\r\n  var _attributedString$run, _attributedString$run2;\r\n  return ((_attributedString$run = attributedString.runs) === null || _attributedString$run === void 0 ? void 0 : (_attributedString$run2 = _attributedString$run[0]) === null || _attributedString$run2 === void 0 ? void 0 : _attributedString$run2.attributes) || {};\r\n};\r\n\r\n/**\r\n * Performs Knuth & Plass line breaking algorithm\r\n * Fallbacks to best fit algorithm if latter not successful\r\n *\r\n * @param {Object} options layout options\r\n */\r\nvar linebreaker = function linebreaker(options) {\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @param {number[]} availableWidths available widths\r\n   * @returns {AttributedString[]} attributed strings\r\n   */\r\n  return function (attributedString, availableWidths) {\r\n    var tolerance = options.tolerance || 4;\r\n    var style = getStyles(attributedString);\r\n    var nodes = getNodes(attributedString, style, options);\r\n\r\n    /** @type {Object[]} */\r\n    var breaks = linebreak(nodes, availableWidths, {\r\n      tolerance: tolerance\r\n    });\r\n\r\n    // Try again with a higher tolerance if the line breaking failed.\r\n    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\r\n      tolerance += TOLERANCE_STEPS;\r\n      breaks = linebreak(nodes, availableWidths, {\r\n        tolerance: tolerance\r\n      });\r\n    }\r\n    if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {\r\n      breaks = applyBestFit(nodes, availableWidths);\r\n    }\r\n    return breakLines(attributedString, nodes, breaks.slice(1));\r\n  };\r\n};\r\n\r\nvar WHITESPACE_PRIORITY = 1;\r\nvar LETTER_PRIORITY = 2;\r\nvar EXPAND_WHITESPACE_FACTOR = {\r\n  before: 0.5,\r\n  after: 0.5,\r\n  priority: WHITESPACE_PRIORITY,\r\n  unconstrained: false\r\n};\r\nvar EXPAND_CHAR_FACTOR = {\r\n  before: 0.14453125,\r\n  // 37/256\r\n  after: 0.14453125,\r\n  priority: LETTER_PRIORITY,\r\n  unconstrained: false\r\n};\r\nvar SHRINK_WHITESPACE_FACTOR = {\r\n  before: -0.04296875,\r\n  // -11/256\r\n  after: -0.04296875,\r\n  priority: WHITESPACE_PRIORITY,\r\n  unconstrained: false\r\n};\r\nvar SHRINK_CHAR_FACTOR = {\r\n  before: -0.04296875,\r\n  after: -0.04296875,\r\n  priority: LETTER_PRIORITY,\r\n  unconstrained: false\r\n};\r\nvar getCharFactor = function getCharFactor(direction, options) {\r\n  var expandCharFactor = options.expandCharFactor || {};\r\n  var shrinkCharFactor = options.shrinkCharFactor || {};\r\n  return direction === 'GROW' ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\r\n};\r\nvar getWhitespaceFactor = function getWhitespaceFactor(direction, options) {\r\n  var expandWhitespaceFactor = options.expandWhitespaceFactor || {};\r\n  var shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\r\n  return direction === 'GROW' ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\r\n};\r\nvar factor = function factor(direction, options) {\r\n  return function (glyphs) {\r\n    var charFactor = getCharFactor(direction, options);\r\n    var whitespaceFactor = getWhitespaceFactor(direction, options);\r\n    var factors = [];\r\n    for (var index = 0; index < glyphs.length; index += 1) {\r\n      var f = void 0;\r\n      var glyph = glyphs[index];\r\n      if (isWhiteSpace(glyph)) {\r\n        f = Object.assign({}, whitespaceFactor);\r\n        if (index === glyphs.length - 1) {\r\n          f.before = 0;\r\n          if (index > 0) {\r\n            factors[index - 1].after = 0;\r\n          }\r\n        }\r\n      } else if (glyph.isMark && index > 0) {\r\n        f = Object.assign({}, factors[index - 1]);\r\n        f.before = 0;\r\n        factors[index - 1].after = 0;\r\n      } else {\r\n        f = Object.assign({}, charFactor);\r\n      }\r\n      factors.push(f);\r\n    }\r\n    return factors;\r\n  };\r\n};\r\nvar getFactors = function getFactors(gap, line, options) {\r\n  var direction = gap > 0 ? 'GROW' : 'SHRINK';\r\n  var getFactor = factor(direction, options);\r\n  var factors = line.runs.reduce(function (acc, run) {\r\n    return acc.concat(getFactor(run.glyphs));\r\n  }, []);\r\n  factors[0].before = 0;\r\n  factors[factors.length - 1].after = 0;\r\n  return factors;\r\n};\r\n\r\n/* eslint-disable no-multi-assign */\r\nvar KASHIDA_PRIORITY = 0;\r\nvar NULL_PRIORITY = 3;\r\nvar getDistances = function getDistances(gap, factors) {\r\n  var total = 0;\r\n  var priorities = [];\r\n  var unconstrained = [];\r\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {\r\n    priorities[_priority] = unconstrained[_priority] = 0;\r\n  }\r\n\r\n  // sum the factors at each priority\r\n  for (var j = 0; j < factors.length; j += 1) {\r\n    var f = factors[j];\r\n    var sum = f.before + f.after;\r\n    total += sum;\r\n    priorities[f.priority] += sum;\r\n    if (f.unconstrained) {\r\n      unconstrained[f.priority] += sum;\r\n    }\r\n  }\r\n\r\n  // choose the priorities that need to be applied\r\n  var highestPriority = -1;\r\n  var highestPrioritySum = 0;\r\n  var remainingGap = gap;\r\n  var priority;\r\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\r\n    var prioritySum = priorities[priority];\r\n    if (prioritySum !== 0) {\r\n      if (highestPriority === -1) {\r\n        highestPriority = priority;\r\n        highestPrioritySum = prioritySum;\r\n      }\r\n\r\n      // if this priority covers the remaining gap, we're done\r\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\r\n        priorities[priority] = remainingGap / prioritySum;\r\n        unconstrained[priority] = 0;\r\n        remainingGap = 0;\r\n        break;\r\n      }\r\n\r\n      // mark that we need to use 100% of the adjustment from\r\n      // this priority, and subtract the space that it consumes\r\n      priorities[priority] = 1;\r\n      remainingGap -= prioritySum;\r\n\r\n      // if this priority has unconstrained glyphs, let them consume the remaining space\r\n      if (unconstrained[priority] !== 0) {\r\n        unconstrained[priority] = remainingGap / unconstrained[priority];\r\n        remainingGap = 0;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // zero out remaining priorities (if any)\r\n  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {\r\n    priorities[p] = 0;\r\n    unconstrained[p] = 0;\r\n  }\r\n\r\n  // if there is still space left over, assign it to the highest priority that we saw.\r\n  // this violates their factors, but it only happens in extreme cases\r\n  if (remainingGap > 0 && highestPriority > -1) {\r\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\r\n  }\r\n\r\n  // create and return an array of distances to add to each glyph's advance\r\n  var distances = [];\r\n  for (var index = 0; index < factors.length; index += 1) {\r\n    // the distance to add to this glyph is the sum of the space to add\r\n    // after this glyph, and the space to add before the next glyph\r\n    var _f = factors[index];\r\n    var next = factors[index + 1];\r\n    var dist = _f.after * priorities[_f.priority];\r\n    if (next) {\r\n      dist += next.before * priorities[next.priority];\r\n    }\r\n\r\n    // if this glyph is unconstrained, add the unconstrained distance as well\r\n    if (_f.unconstrained) {\r\n      dist += _f.after * unconstrained[_f.priority];\r\n      if (next) {\r\n        dist += next.before * unconstrained[next.priority];\r\n      }\r\n    }\r\n    distances.push(dist);\r\n  }\r\n  return distances;\r\n};\r\n\r\n/**\r\n * Adjust run positions by given distances\r\n *\r\n * @param {number[]} distances\r\n * @param {Object} line\r\n * @returns {Object} line\r\n */\r\nvar justifyLine = function justifyLine(distances, line) {\r\n  var index = 0;\r\n  for (var _iterator = _createForOfIteratorHelperLoose(line.runs), _step; !(_step = _iterator()).done;) {\r\n    var run = _step.value;\r\n    for (var _iterator2 = _createForOfIteratorHelperLoose(run.positions), _step2; !(_step2 = _iterator2()).done;) {\r\n      var position = _step2.value;\r\n      position.xAdvance += distances[index++];\r\n    }\r\n  }\r\n  return line;\r\n};\r\n\r\n/**\r\n * A JustificationEngine is used by a Typesetter to perform line fragment\r\n * justification. This implementation is based on a description of Apple's\r\n * justification algorithm from a PDF in the Apple Font Tools package.\r\n *\r\n * // TODO: Make it immutable\r\n *\r\n * @param {Object} options layout options\r\n */\r\nvar justification = function justification(options) {\r\n  /**\r\n   * @param {Object} line\r\n   * @returns {Object} line\r\n   */\r\n  return function (line) {\r\n    var gap = line.box.width - advanceWidth(line);\r\n    if (gap === 0) return; // Exact fit\r\n\r\n    var factors = getFactors(gap, line, options);\r\n    var distances = getDistances(gap, factors);\r\n    return justifyLine(distances, line);\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Returns attributed string ascent\r\n *\r\n * @param {AttributedString} attributedString attributed string\r\n * @returns {number} ascent\r\n */\r\nvar ascent = function ascent(attributedString) {\r\n  var reducer = function reducer(acc, run) {\r\n    return Math.max(acc, ascent$1(run));\r\n  };\r\n  return attributedString.runs.reduce(reducer, 0);\r\n};\r\n\r\n/* eslint-disable no-param-reassign */\r\n\r\n\r\n// The base font size used for calculating underline thickness.\r\nvar BASE_FONT_SIZE = 12;\r\n\r\n/**\r\n * A TextDecorationEngine is used by a Typesetter to generate\r\n * DecorationLines for a line fragment, including underlines\r\n * and strikes.\r\n */\r\nvar textDecoration = function textDecoration() {\r\n  return function (lineFragment) {\r\n    var x = lineFragment.overflowLeft || 0;\r\n    var overflowRight = lineFragment.overflowRight || 0;\r\n    var maxX = advanceWidth(lineFragment) - overflowRight;\r\n    lineFragment.decorationLines = [];\r\n    for (var i = 0; i < lineFragment.runs.length; i += 1) {\r\n      var run = lineFragment.runs[i];\r\n      var width = Math.min(maxX - x, advanceWidth$1(run));\r\n      var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\r\n      if (run.attributes.underline) {\r\n        var rect = {\r\n          x: x,\r\n          y: ascent(lineFragment) + thickness * 2,\r\n          width: width,\r\n          height: thickness\r\n        };\r\n        var line = {\r\n          rect: rect,\r\n          opacity: run.attributes.opacity,\r\n          color: run.attributes.underlineColor || 'black',\r\n          style: run.attributes.underlineStyle || 'solid'\r\n        };\r\n        lineFragment.decorationLines.push(line);\r\n      }\r\n      if (run.attributes.strike) {\r\n        var y = ascent(lineFragment) - ascent$1(run) / 3;\r\n        var _rect = {\r\n          x: x,\r\n          y: y,\r\n          width: width,\r\n          height: thickness\r\n        };\r\n        var _line = {\r\n          rect: _rect,\r\n          opacity: run.attributes.opacity,\r\n          color: run.attributes.strikeColor || 'black',\r\n          style: run.attributes.strikeStyle || 'solid'\r\n        };\r\n        lineFragment.decorationLines.push(_line);\r\n      }\r\n      x += width;\r\n    }\r\n    return lineFragment;\r\n  };\r\n};\r\n\r\nvar ignoredScripts = ['Common', 'Inherited', 'Unknown'];\r\n\r\n/**\r\n * @typedef {import('../../types.js').AttributedString} AttributedString\r\n */\r\n\r\n/**\r\n * Resolves unicode script in runs, grouping equal runs together\r\n */\r\nvar scriptItemizer = function scriptItemizer() {\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\r\n  return function (attributedString) {\r\n    var string = attributedString.string;\r\n    var lastScript = 'Unknown';\r\n    var lastIndex = 0;\r\n    var index = 0;\r\n    var res = [];\r\n    if (!string) return empty();\r\n    for (var i = 0; i < string.length; i += 1) {\r\n      var char = string[i];\r\n      var codePoint = char.codePointAt();\r\n      var script = unicode.getScript(codePoint);\r\n      if (script !== lastScript && !ignoredScripts.includes(script)) {\r\n        if (lastScript !== 'Unknown') {\r\n          res.push({\r\n            start: lastIndex,\r\n            end: index,\r\n            attributes: {\r\n              script: lastScript\r\n            }\r\n          });\r\n        }\r\n        lastIndex = index;\r\n        lastScript = script;\r\n      }\r\n      index += char.length;\r\n    }\r\n    if (lastIndex < string.length) {\r\n      res.push({\r\n        start: lastIndex,\r\n        end: string.length,\r\n        attributes: {\r\n          script: lastScript\r\n        }\r\n      });\r\n    }\r\n    return {\r\n      string: string,\r\n      runs: res\r\n    };\r\n  };\r\n};\r\n\r\nvar SOFT_HYPHEN = \"\\xAD\";\r\nvar hyphenator = hyphen(pattern);\r\n\r\n/**\r\n * @param {string} word\r\n * @returns {string[]} word parts\r\n */\r\nvar splitHyphen = function splitHyphen(word) {\r\n  return word.split(SOFT_HYPHEN);\r\n};\r\nvar cache = {};\r\n\r\n/**\r\n * @param {string} word\r\n * @returns {string[]} word parts\r\n */\r\nvar getParts = function getParts(word) {\r\n  var base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\r\n  return splitHyphen(base);\r\n};\r\nvar wordHyphenation = function wordHyphenation() {\r\n  /**\r\n   * @param {string} word word\r\n   * @returns {string[]} word parts\r\n   */\r\n  return function (word) {\r\n    var cacheKey = \"_\" + word;\r\n    if (isNil(word)) return [];\r\n    if (cache[cacheKey]) return cache[cacheKey];\r\n    cache[cacheKey] = getParts(word);\r\n    return cache[cacheKey];\r\n  };\r\n};\r\n\r\n/**\r\n * @typedef {import('../../types.js').AttributedString} AttributedString\r\n * @typedef {import('../../types.js').Run} Run\r\n */\r\n\r\n/**\r\n * @param {Run} run run\r\n * @returns {number}\r\n */\r\nvar getFontSize = function getFontSize(run) {\r\n  return run.attributes.fontSize || 12;\r\n};\r\n\r\n/**\r\n * Resolve font runs in an AttributedString, grouping equal\r\n * runs and performing font substitution where necessary.\r\n */\r\nvar fontSubstitution = function fontSubstitution() {\r\n  /**\r\n   * @param {AttributedString} attributedString attributed string\r\n   * @returns {AttributedString} attributed string\r\n   */\r\n  return function (attributedString) {\r\n    var string = attributedString.string,\r\n      runs = attributedString.runs;\r\n    var lastFont = null;\r\n    var lastIndex = 0;\r\n    var index = 0;\r\n    var res = [];\r\n    if (!string) return empty();\r\n    for (var _iterator = _createForOfIteratorHelperLoose(runs), _step; !(_step = _iterator()).done;) {\r\n      var run = _step.value;\r\n      var _fontSize = getFontSize(run);\r\n      var defaultFont = run.attributes.font;\r\n      if (string.length === 0) {\r\n        res.push({\r\n          start: 0,\r\n          end: 0,\r\n          attributes: {\r\n            font: defaultFont\r\n          }\r\n        });\r\n        break;\r\n      }\r\n      for (var _iterator2 = _createForOfIteratorHelperLoose(string.slice(run.start, run.end)), _step2; !(_step2 = _iterator2()).done;) {\r\n        var char = _step2.value;\r\n        var font = defaultFont;\r\n        if (font !== lastFont) {\r\n          if (lastFont) {\r\n            res.push({\r\n              start: lastIndex,\r\n              end: index,\r\n              attributes: {\r\n                font: lastFont,\r\n                scale: lastFont ? _fontSize / lastFont.unitsPerEm : 0\r\n              }\r\n            });\r\n          }\r\n          lastFont = font;\r\n          lastIndex = index;\r\n        }\r\n        index += char.length;\r\n      }\r\n    }\r\n    if (lastIndex < string.length) {\r\n      var fontSize = getFontSize(last(runs));\r\n      res.push({\r\n        start: lastIndex,\r\n        end: string.length,\r\n        attributes: {\r\n          font: lastFont,\r\n          scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\r\n        }\r\n      });\r\n    }\r\n    return {\r\n      string: string,\r\n      runs: res\r\n    };\r\n  };\r\n};\r\n\r\nexport { bidiEngine as bidi, layoutEngine as default, fontSubstitution, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}